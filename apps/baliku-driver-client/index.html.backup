<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#0ea5e9" />
    <link rel="manifest" href="/manifest.webmanifest" />
    <title>Baliku Driver</title>
    <style>
      :root{
        color-scheme: dark;
      }

      /* Responsive font sizes */
      html{
        font-size:14px; /* Desktop default */
      }

      /* Mobile version (280-400px): font-size 10px */
      @media (max-width:400px){
        html{
          font-size:10px;
        }
      }

      /* Desktop version (>400px): font-size 14px */
      @media (min-width:401px){
        html{
          font-size:14px;
        }
      }

      html,body{
        min-width:280px; /* Minimum width for mobile devices (280-400px range) */
      }
      body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;margin:0;background:#0b1020;color:#e6edf3;transition:background .3s ease,color .3s ease}
      header{position:sticky;top:0;background:#0ea5e9;color:#00131f;padding:10px 16px;font-weight:700;display:flex;align-items:center;gap:10px;z-index:40}
      main{padding:16px;max-width:980px;margin:0 auto}
      .card{background:#0f172a;border:1px solid #1f2a44;border-radius:12px;padding:16px;margin:12px 0}
      button{background:#0ea5e9;border:0;color:#00131f;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer;display:inline-flex;align-items:center;gap:6px;transition:background .2s ease,transform .2s ease}
      button:hover{background:#f3d30d;transform:translateY(-1px)}
      button:disabled{opacity:.6;cursor:not-allowed}
      button[style*="background:#dc2626"]:hover{background:#b91c1c;transform:translateY(-1px)}
      .menu-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
      .menu-header h2{margin:0}
      .icon-btn{width:36px;height:36px;padding:8px;justify-content:center}
      .icon-btn:hover{background:#f3d30d;transform:translateY(-1px)}
      .icon-btn svg{width:18px;height:18px}
      .hamburger{background:#0ea5e9;border:0;width:40px;height:40px;border-radius:8px;display:inline-flex;align-items:center;justify-content:center}
      .hamburger:hover{background:#f3d30d;transform:translateY(-1px)}
      .hamburger svg{width:22px;height:22px}
      .drawer{position:fixed;inset:0;pointer-events:none;z-index:50}
      .drawer .overlay{position:absolute;inset:0;background:rgba(0,0,0,.5);opacity:0;transition:opacity .2s}
      .drawer .panel{position:absolute;top:0;left:0;height:100%;width:260px;background:#0f172a;border-right:1px solid #1f2a44;transform:translateX(-100%);transition:transform .2s;overflow-y:auto}
      .drawer.open{pointer-events:auto}
      .drawer.open .overlay{opacity:1}
      .drawer.open .panel{transform:translateX(0)}
      body.login-active{overflow:hidden}
      #login-screen{position:fixed;inset:0;background:#4a4a4a;display:flex;align-items:center;justify-content:center;z-index:200;padding:16px}
      #login-screen.hidden{display:none}
      .login-card{width:100%;max-width:420px;background:#ffffff;border-radius:16px;overflow:hidden;box-shadow:0 20px 45px rgba(0,0,0,.45);display:flex;flex-direction:column}
      .login-header{height:140px;background:linear-gradient(135deg,#0f4c5c 0%,#1a5f6f 50%,#0d2b35 100%);position:relative;overflow:hidden}
      .login-header::before{content:'';position:absolute;inset:0;background-image:url("data:image/svg+xml,%3Csvg width='300' height='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3ClinearGradient id='leaf1' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%2328a745;stop-opacity:0.7'/%3E%3Cstop offset='100%25' style='stop-color:%2320c997;stop-opacity:0.5'/%3E%3C/linearGradient%3E%3ClinearGradient id='leaf2' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%2317a2b8;stop-opacity:0.6'/%3E%3Cstop offset='100%25' style='stop-color:%2328a745;stop-opacity:0.4'/%3E%3C/linearGradient%3E%3C/defs%3E%3Cpath d='M80 40 Q120 20 160 50 Q180 70 160 90 Q140 110 100 100 Q60 90 50 60 Q40 50 80 40 Z' fill='url(%23leaf1)' opacity='0.8'/%3E%3Cpath d='M200 80 Q240 60 280 90 Q300 110 280 130 Q260 150 220 140 Q180 130 170 100 Q160 90 200 80 Z' fill='url(%23leaf2)' opacity='0.7'/%3E%3Cpath d='M40 120 Q80 100 120 130 Q140 150 120 170 Q100 190 60 180 Q20 170 10 140 Q0 130 40 120 Z' fill='url(%23leaf1)' opacity='0.6'/%3E%3Cpath d='M160 140 Q200 120 240 150 Q260 170 240 190 Q220 210 180 200 Q140 190 130 160 Q120 150 160 140 Z' fill='url(%23leaf2)' opacity='0.7'/%3E%3Cpath d='M220 20 Q260 0 300 30 Q320 50 300 70 Q280 90 240 80 Q200 70 190 40 Q180 30 220 20 Z' fill='url(%23leaf1)' opacity='0.5'/%3E%3Cpath d='M60 200 Q100 180 140 210 Q160 230 140 250 Q120 270 80 260 Q40 250 30 220 Q20 210 60 200 Z' fill='url(%23leaf2)' opacity='0.6'/%3E%3C/svg%3E");background-size:300px 300px;background-repeat:repeat;opacity:0.4;background-position:0 0}
      .login-header::after{content:'';position:absolute;inset:0;background:radial-gradient(circle at 30%25 40%25,rgba(40,167,69,.15) 0%25,transparent 50%25),radial-gradient(circle at 70%25 60%25,rgba(32,201,151,.12) 0%25,transparent 50%25),radial-gradient(circle at 50%25 80%25,rgba(23,162,184,.1) 0%25,transparent 50%25)}
      .login-body{padding:32px 28px;display:flex;flex-direction:column;gap:20px;background:#ffffff}
      .login-card h2{margin:0 0 8px;text-align:center;font-size:24px;font-weight:700;color:#8b5cf6;text-transform:uppercase;letter-spacing:1px}
      .login-role-group{display:flex;gap:12px;justify-content:center;margin-bottom:8px}
      .login-role-btn{background:#2563eb;color:#ffffff;border:none;padding:10px 24px;border-radius:20px;font-size:14px;font-weight:600;cursor:pointer;transition:all .2s ease;flex:1;max-width:140px;display:flex;align-items:center;justify-content:space-between;gap:8px}
      .login-role-btn.active{background:#1e40af}
      .login-role-btn:not(.active){background:#3b82f6;opacity:0.8}
      .login-role-btn:hover{opacity:1;transform:translateY(-1px)}
      .login-role-btn .role-checkbox{width:18px;height:18px;cursor:pointer;accent-color:#ffffff;flex-shrink:0}
      .login-input-wrapper{position:relative;display:flex;align-items:center}
      .login-input-icon{position:absolute;left:12px;width:20px;height:20px;color:#9ca3af;pointer-events:none}
      .login-card label{display:flex;flex-direction:column;font-size:14px;gap:8px;color:#374151}
      .login-card input[type="text"],.login-card input[type="password"]{padding:12px 12px 12px 40px;border-radius:10px;border:1px solid #e5e7eb;background:#f3f4f6;color:#1f2937;font-size:14px;width:100%;box-sizing:border-box}
      .login-card input[type="text"]:focus,.login-card input[type="password"]:focus{outline:none;border-color:#8b5cf6;background:#ffffff}
      .login-card input[type="text"]::placeholder,.login-card input[type="password"]::placeholder{color:#9ca3af}
      #login-submit{width:100%;background:#22c55e;color:#ffffff;border:none;padding:14px;border-radius:10px;font-size:16px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;cursor:pointer;transition:all .2s ease;margin-top:8px}
      #login-submit:hover:not(:disabled){background:#16a34a;transform:translateY(-1px);box-shadow:0 4px 12px rgba(34,197,94,.3)}
      #login-submit:disabled{opacity:.6;cursor:not-allowed}
      #login-status{min-height:18px;font-size:13px;color:#ef4444;text-align:center;margin-top:-8px}
      ul{list-style:none;padding:0;margin:0;display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px}
      li{background:#0b1225;border:1px solid #1f2a44;border-radius:10px;padding:10px}
      table{width:100%;border-collapse:collapse}
      th,td{border:1px solid #1f2a44;padding:6px 8px;text-align:left}
      #rows th,#rows td{font-size:14px}
      #rows button{font-size:1.3rem;display:inline-flex;align-items:center;justify-content:center;gap:4px}
      #rows button:hover{background:#f3d30d}
      #rows button svg{width:16px;height:16px}
      .group-header{background:#1e293b;border-top:2px solid #0ea5e9;border-bottom:1px solid #334155}
      .group-header-cell{font-weight:700;color:#f8e409;text-align:left;padding:12px 8px;font-size:1.1rem}
      #buttons-container{display:flex;width:100%;border-bottom:1px solid #1f2a44}
      #status-buttons-section{padding:12px 16px;display:flex;gap:16px;flex-wrap:wrap;width:50%;box-sizing:border-box}
      #htx-actions-section{padding:12px 16px;display:flex;gap:12px;flex-wrap:wrap;align-items:center;width:50%;box-sizing:border-box;justify-content:flex-end}
      .status-button-wrapper{display:flex;flex-direction:column;align-items:center;width:60px}
      .status-button{background:#e9bc0e;border:0;color:#00131f;padding:12px 16px;border-radius:10px;display:flex;align-items:center;justify-content:center;gap:8px;min-width:10px;transition:background .2s ease,transform .2s ease}
      .status-button:hover{background:#f3d30d;transform:translateY(-1px)}
      .status-button svg{width:20px;height:20px}
      .status-button-label{margin-top:6px;text-align:center;font-size:14px}
      .htx-action-button{background:#c80c94;border:0;color:#ffffff;padding:10px 20px;border-radius:8px;font-weight:600;font-size:10px;cursor:pointer;transition:background .2s ease,transform .2s ease;white-space:nowrap}
      .htx-action-button:hover{background:#a00a7a;transform:translateY(-1px)}
      .htx-action-button.change-car{background:#e50b37}
      .htx-action-button.change-car:hover{background:#c0092d}
      .dropdown-list{max-height:200px;overflow-y:auto}
      .dropdown-option{padding:10px 12px;cursor:pointer;color:#e6edf3;border-bottom:1px solid #1f2a44;transition:background .2s ease}
      .dropdown-option:hover{background:#1f2a44}
      .dropdown-option:last-child{border-bottom:none}
      .dropdown-option.highlight{background:#0ea5e9;color:#00131f}
      .toast{position:fixed;bottom:24px;left:50%;transform:translateX(-50%);background:#0ea5e9;color:#00131f;padding:12px 18px;border-radius:8px;font-weight:600;box-shadow:0 4px 12px rgba(0,0,0,.3);opacity:0;pointer-events:none;transition:opacity .2s ease,transform .2s ease;z-index:60}
      .toast.show{opacity:1;transform:translate(-50%,-6px)}
      .muted{opacity:.8}
      .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.5);padding:16px}
      .modal.open{display:flex}
      .modal-card{background:#0f172a;border:1px solid #1f2a44;border-radius:12px;max-width:720px;width:100%;max-height:80vh;overflow:auto}
      .modal-header{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid #1f2a44}
      .modal-body{padding:16px}
      .kv{display:grid;grid-template-columns:200px 1fr;gap:8px;border-bottom:1px dashed #1f2a44;padding:6px 0}
      @media (max-width:768px){
        header{padding:8px 12px;gap:8px}
        header button{padding:8px 12px}
        main{padding:12px;max-width:100%}
        .card{padding:12px;margin:10px 0}
        button{width:100%;padding:10px 12px}
        .icon-btn{width:32px;height:32px}
        .hamburger{width:36px;height:36px}
        #status{display:none}
        ul{grid-template-columns:1fr}
        table{font-size:1rem}
        th,td{padding:6px}
        .kv{grid-template-columns:1fr;gap:6px}
        .status-button-wrapper{width:60px;align-items:center}
        .status-button{width:100%;padding:10px 12px;min-width:10px;font-size:1.3rem}
        .status-button svg{width:16px;height:16px}
        .status-button-label{font-size:14px;margin-top:4px}
        #buttons-container{flex-direction:column}
        #status-buttons-section{flex-direction:column;gap:10px;padding:10px 12px;flex-wrap:wrap;justify-content:flex-start;width:100%}
        #htx-actions-section{flex-direction:row;gap:10px;padding:10px 12px;flex-wrap:wrap;justify-content:flex-start;width:100%}
        .htx-action-button{padding:10px 16px;font-size:1.2rem}
        .modal-card{width:100%;max-height:85vh;border-radius:10px}
        .modal-header{padding:10px 12px;font-size:1.4rem}
        .modal-header button{width:auto;padding:6px 10px;font-size:1.2rem}
        .modal-body{padding:10px}
        .kv{grid-template-columns:1fr;gap:5px}
        .kv .muted{font-size:1.2rem}
        .kv input{padding:8px;font-size:1.3rem}
        #details-content{font-size:1.3rem}
        #filters-card{padding:12px}
        #checkbox-filters-container{flex-wrap:wrap}
        #checkbox-filters-container label{font-size:1.3rem}
        .drawer .panel{width:80vw;max-width:300px}
      #rows-card{overflow-x:auto}
      #rows{min-width:600px}
      table{font-size:1.2rem}
      th,td{padding:5px 6px}
      #rows th,#rows td{font-size:1.2rem}
      #rows button{padding:6px 8px;font-size:1.2rem;gap:4px;width:auto;border-radius:8px}
      #rows button svg{width:14px;height:14px}
      .group-header-cell{font-size:1rem;padding:8px 6px}

      @media (max-width:400px){
        #status-buttons-section{flex-direction:row;flex-wrap:nowrap;gap:8px;padding:10px 12px;justify-content:flex-start;overflow-x:auto}
        #htx-actions-section{flex-direction:row;flex-wrap:nowrap;gap:8px;padding:10px 12px;justify-content:flex-start;overflow-x:auto}
        .status-button-wrapper{width:60px;align-items:center}
        .status-button{min-width:10px;width:60px;padding:8px 10px}
        .status-button-label{font-size:12px;margin-top:4px}
        .htx-action-button{padding:8px 12px;font-size:1.1rem}
      }
      }
    </style>
  </head>
  <body>
    <div id="login-screen" class="hidden">
      <div class="login-card">
        <div class="login-header"></div>
        <div class="login-body">
          <h2>LOGIN</h2>
          <div class="login-role-group">
            <button type="button" class="login-role-btn active" data-role="driver">
              <span>Driver</span>
              <input type="checkbox" class="role-checkbox" checked />
            </button>
            <button type="button" class="login-role-btn" data-role="guide">
              <span>Guide</span>
              <input type="checkbox" class="role-checkbox" />
            </button>
          </div>
          <label>
            <div class="login-input-wrapper">
              <svg class="login-input-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                <circle cx="12" cy="7" r="4"></circle>
              </svg>
              <input type="text" id="login-name" list="login-name-options" placeholder="Username" autocomplete="off" />
            </div>
          </label>
          <datalist id="login-name-options"></datalist>
          <label>
            <div class="login-input-wrapper">
              <svg class="login-input-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
              </svg>
              <input type="password" id="login-password" placeholder="Password" autocomplete="off" />
            </div>
          </label>
          <button id="login-submit" disabled>LOG IN</button>
          <div id="login-status"></div>
        </div>
      </div>
    </div>
    <header>
      <button id="btn-hamburger" class="hamburger" aria-label="Open menu" title="Menu">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/>
        </svg>
      </button>
      <div style="flex:1">Baliku Driver</div>
      <button id="refresh" title="Sync" style="display:inline-flex;align-items:center;gap:6px">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
          <path d="M21 3v5h-5"/>
          <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
          <path d="M8 16H3v5"/>
        </svg>
        <span>Sync</span>
      </button>
      <span id="status" class="muted" style="margin-left:8px"></span>
    </header>
    <div id="app-drawer" class="drawer" aria-hidden="true">
      <div class="overlay"></div>
      <div class="panel">
        <div style="padding:16px;border-bottom:1px solid #1f2a44;display:flex;justify-content:space-between;align-items:center">
          <strong>Menu</strong>
          <button id="btn-drawer-close" class="icon-btn" aria-label="Close menu" title="Close">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
          </button>
        </div>
        <div style="padding:12px 16px;display:flex;flex-direction:column;gap:10px">
          <button id="menu-order-schedule">Order Schedule</button>
          <button id="menu-services">Services</button>
          <button id="menu-driver">Driver List</button>
          <button id="menu-guide">Guide List</button>
          <button id="menu-car">Car List</button>
          <button id="menu-places">Places</button>
          <button id="menu-agency">Agency</button>
          <button id="menu-pricelist">Pricelist</button>
          <button id="menu-pending-order">Pending Order</button>
        </div>
        <div style="padding:16px;border-top:1px solid #1f2a44;display:flex;justify-content:space-between;align-items:center">
          <strong>Settings</strong>
        </div>
        <div style="padding:12px 16px;display:flex;flex-direction:column;gap:8px">
          <button id="btn-database">Database</button>
          <button id="btn-api-connection">API Connection</button>
        </div>
        <div style="padding:12px 16px;border-top:1px solid #1f2a44">
          <button id="btn-logout" style="width:100%;background:#dc2626">Logout</button>
        </div>
      </div>
    </div>
    <main>
      <div class="card" id="filters-card">
        <h3 id="filters-title">Order filters</h3>
        <div style="display:flex;gap:12px;align-items:flex-end">
          <div style="width:50%;flex:0 0 50%">
            <label>
              
              <input type="text" id="search-filter" placeholder="Search" style="width:70%;padding:8px;border-radius:8px;border:1px solid #1f2a44;background:#0b1225;color:#e6edf3" />
            </label>
          </div>
          <div id="checkbox-filters-container" style="width:50%;flex:0 0 50%;display:flex;gap:12px;align-items:center">
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer" id="checkbox-48-hours-label">
              <input type="checkbox" id="checkbox-48-hours" />
              <span class="muted">48 Hours</span>
            </label>
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer" id="checkbox-7-days-label">
              <input type="checkbox" id="checkbox-7-days" />
              <span class="muted">7 Days</span>
            </label>
            <label style="display:none;align-items:center;gap:6px;cursor:pointer" id="checkbox-pcon-label">
              <input type="checkbox" id="checkbox-pcon" />
              <span class="muted">PCON</span>
            </label>
            <label style="display:none;align-items:center;gap:6px;cursor:pointer" id="checkbox-pamm-label">
              <input type="checkbox" id="checkbox-pamm" />
              <span class="muted">PAMM</span>
            </label>
            <label style="display:none;align-items:center;gap:6px;cursor:pointer" id="checkbox-pcan-label">
              <input type="checkbox" id="checkbox-pcan" />
              <span class="muted">PCAN</span>
            </label>
          </div>
        </div>
      </div>
      
      <div class="card" id="rows-card" style="display:none">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
          <h3 id="rows-title" style="margin:0">Rows</h3>
          <div class="rows-actions" style="display:flex;gap:8px;align-items:center">
            <button id="import-csv-btn">Import CSV</button>
            <input type="file" id="csv-file-input" accept=".csv" style="display:none" />
            <button id="add-row-btn">Add</button>
          </div>
        </div>
        <div style="overflow:auto">
          <table id="rows"></table>
        </div>
      </div>
    </main>
    <div id="details-modal" class="modal" aria-hidden="true">
      <div class="modal-card">
        <div class="modal-header">
          <strong id="details-modal-title">Row Details</strong>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="details-edit">Edit</button>
            <button id="details-save" style="display:none">Save</button>
            <button id="details-cancel" style="display:none">Cancel</button>
            <button id="details-delete" style="background:#dc2626;color:#ffffff">Delete</button>
            <button id="details-close">Close</button>
          </div>
        </div>
        <div id="buttons-container" style="display:none;border-bottom:1px solid #1f2a44">
          <div id="status-buttons-section" style="display:none">
            <div class="status-button-wrapper">
              <button class="status-button" title="Before Pickup" data-status-value="BEFORE_PICKUP">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 21s-6-5.373-6-10a6 6 0 1 1 12 0c0 4.627-6 10-6 10Z"/>
                  <circle cx="12" cy="11" r="2"/>
                </svg>
              </button>
              <span class="muted status-button-label">Before Pickup</span>
            </div>
            <div class="status-button-wrapper">
              <button class="status-button" title="Waiting Customer" data-status-value="WAITING_FOR_CUSTOMER">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 21s-6-5.373-6-10a6 6 0 1 1 12 0c0 4.627-6 10-6 10Z"/>
                  <circle cx="12" cy="11" r="2"/>
                </svg>
              </button>
              <span class="muted status-button-label">Waiting Customer</span>
            </div>
            <div class="status-button-wrapper">
              <button class="status-button" title="After Pickup" data-status-value="AFTER_PICKUP">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 21s-6-5.373-6-10a6 6 0 1 1 12 0c0 4.627-6 10-6 10Z"/>
                  <circle cx="12" cy="11" r="2"/>
                </svg>
              </button>
              <span class="muted status-button-label">After Pickup</span>
            </div>
            <div class="status-button-wrapper">
              <button class="status-button" title="Completed" data-status-value="COMPLETED">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 21s-6-5.373-6-10a6 6 0 1 1 12 0c0 4.627-6 10-6 10Z"/>
                  <circle cx="12" cy="11" r="2"/>
                </svg>
              </button>
              <span class="muted status-button-label">Completed</span>
            </div>
          </div>
          <div id="htx-actions-section" style="display:none">
            <button class="htx-action-button" id="btn-send-to-htx" title="Send to HTX">SEND TO HTX</button>
            <button class="htx-action-button change-car" id="btn-change-car" title="Change Car">CHANGE CAR</button>
          </div>
        </div>
        <div id="pending-buttons-section" style="display:none">
          <div class="status-button-wrapper">
            <button class="status-button" title="ACON" data-pending-action="ACON">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 6L9 17l-5-5"/>
              </svg>
            </button>
            <span class="muted status-button-label">ACON</span>
          </div>
          <div class="status-button-wrapper">
            <button class="status-button" title="AAMM" data-pending-action="AAMM">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 6L9 17l-5-5"/>
              </svg>
            </button>
            <span class="muted status-button-label">AAMM</span>
          </div>
          <div class="status-button-wrapper">
            <button class="status-button" title="ACAN" data-pending-action="ACAN">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 6L9 17l-5-5"/>
              </svg>
            </button>
            <span class="muted status-button-label">ACAN</span>
          </div>
          <div class="status-button-wrapper">
            <button class="status-button" title="Action 4" data-pending-action="ACTION4">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 6L9 17l-5-5"/>
              </svg>
            </button>
            <span class="muted status-button-label">Action 4</span>
          </div>
        </div>
        <div id="details-content" class="modal-body"></div>
      </div>
    </div>
    <div id="database-modal" class="modal" aria-hidden="true">
      <div class="modal-card">
        <div class="modal-header">
          <strong>Database Configuration</strong>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="db-edit">Edit</button>
            <button id="db-save" style="display:none">Save</button>
            <button id="db-cancel" style="display:none">Cancel</button>
            <button id="db-close">Close</button>
          </div>
        </div>
        <div id="database-content" class="modal-body"></div>
      </div>
    </div>
    <div id="api-modal" class="modal" aria-hidden="true">
      <div class="modal-card">
        <div class="modal-header">
          <strong>API Connection</strong>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="api-edit">Edit</button>
            <button id="api-save" style="display:none">Save</button>
            <button id="api-cancel" style="display:none">Cancel</button>
            <button id="api-close">Close</button>
          </div>
        </div>
        <div id="api-content" class="modal-body"></div>
      </div>
    </div>
    <div id="status-confirm-modal" class="modal" aria-hidden="true">
      <div class="modal-card" style="max-width:360px">
        <div class="modal-header">
          <strong>Confirmation</strong>
          <button id="status-confirm-close" class="icon-btn" aria-label="Close confirmation" title="Close">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"/>
              <line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
          </button>
        </div>
        <div class="modal-body" style="display:flex;flex-direction:column;gap:16px">
          <div id="status-confirm-message" style="font-size:1rem">Do you want to update location ?</div>
          <div style="display:flex;justify-content:flex-end;gap:10px">
            <button id="status-confirm-no" class="icon-btn" style="background:#1f2937;color:#e6edf3;padding:10px 16px;border-radius:8px;width:auto">No</button>
            <button id="status-confirm-yes" style="background:#0ea5e9;color:#00131f;padding:10px 16px;border-radius:8px;width:auto">Yes</button>
          </div>
        </div>
      </div>
    </div>
    <div id="pending-confirm-modal" class="modal" aria-hidden="true">
      <div class="modal-card" style="max-width:360px">
        <div class="modal-header">
          <strong>Confirmation</strong>
          <button id="pending-confirm-close" class="icon-btn" aria-label="Close confirmation" title="Close">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"/>
              <line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
          </button>
        </div>
        <div class="modal-body" style="display:flex;flex-direction:column;gap:16px">
          <div id="pending-confirm-message" style="font-size:1rem">Are you sure?</div>
          <div style="display:flex;justify-content:flex-end;gap:10px">
            <button id="pending-confirm-no" class="icon-btn" style="background:#1f2937;color:#e6edf3;padding:10px 16px;border-radius:8px;width:auto">No</button>
            <button id="pending-confirm-yes" style="background:#0ea5e9;color:#00131f;padding:10px 16px;border-radius:8px;width:auto">Yes</button>
          </div>
        </div>
      </div>
    </div>
    <div id="toast" class="toast" role="status"></div>
    <script>
      const API_BASE = (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? 'http://localhost:4000' : '';
      const statusEl = document.getElementById('status');
      const rowsCard = document.getElementById('rows-card');
      const rowsTitle = document.getElementById('rows-title');
      const rowsEl = document.getElementById('rows');
      const refreshBtn = document.getElementById('refresh');
      const filtersCard = document.getElementById('filters-card');
      const filtersTitle = document.getElementById('filters-title');
      const searchFilter = document.getElementById('search-filter');
      const checkboxFiltersContainer = document.getElementById('checkbox-filters-container');
      const detailsModal = document.getElementById('details-modal');
      const detailsClose = document.getElementById('details-close');
      const detailsEdit = document.getElementById('details-edit');
      const detailsSave = document.getElementById('details-save');
      const detailsCancel = document.getElementById('details-cancel');
      const detailsDelete = document.getElementById('details-delete');
      const detailsContent = document.getElementById('details-content');
      const detailsModalTitle = document.getElementById('details-modal-title');
      const databaseModal = document.getElementById('database-modal');
      const dbClose = document.getElementById('db-close');
      const dbEdit = document.getElementById('db-edit');
      const dbSave = document.getElementById('db-save');
      const dbCancel = document.getElementById('db-cancel');
      const databaseContent = document.getElementById('database-content');
      const apiModal = document.getElementById('api-modal');
      const apiClose = document.getElementById('api-close');
      const apiEdit = document.getElementById('api-edit');
      const apiSave = document.getElementById('api-save');
      const apiCancel = document.getElementById('api-cancel');
      const apiContent = document.getElementById('api-content');
      const btnHamburger = document.getElementById('btn-hamburger');
      const appDrawer = document.getElementById('app-drawer');
      const btnDrawerClose = document.getElementById('btn-drawer-close');
      const buttonsContainer = document.getElementById('buttons-container');
      const statusButtonsSection = document.getElementById('status-buttons-section');
      const htxActionsSection = document.getElementById('htx-actions-section');
      const pendingButtonsSection = document.getElementById('pending-buttons-section');
      const statusConfirmModal = document.getElementById('status-confirm-modal');
      const statusConfirmMessage = document.getElementById('status-confirm-message');
      const statusConfirmYes = document.getElementById('status-confirm-yes');
      const statusConfirmNo = document.getElementById('status-confirm-no');
      const statusConfirmClose = document.getElementById('status-confirm-close');
      const addRowBtn = document.getElementById('add-row-btn');
      const importCsvBtn = document.getElementById('import-csv-btn');
      const csvFileInput = document.getElementById('csv-file-input');
      const pendingConfirmModal = document.getElementById('pending-confirm-modal');
      const pendingConfirmMessage = document.getElementById('pending-confirm-message');
      const pendingConfirmYes = document.getElementById('pending-confirm-yes');
      const pendingConfirmNo = document.getElementById('pending-confirm-no');
      const pendingConfirmClose = document.getElementById('pending-confirm-close');
      const toastEl = document.getElementById('toast');
      const loginScreen = document.getElementById('login-screen');
      const loginRoleButtons = document.querySelectorAll('.login-role-btn');
      const loginNameInput = document.getElementById('login-name');
      const loginPasswordInput = document.getElementById('login-password');
      const loginSubmit = document.getElementById('login-submit');
      const loginStatus = document.getElementById('login-status');
      const loginNameDatalist = document.getElementById('login-name-options');

      let originalRows = [];
      let currentTable = null;
      let currentMeta = null; // { primaryKey: string[], columns: string[], columnTypes: {} }
      let currentRow = null;
      let editMode = false;
      let addMode = false;
      let dbEditMode = false;
      let pendingStatusUpdate = null;
      let pendingActionRequest = null;
      let holidayApiConfig = {
        endpoint: 'https://suppliers.htxstaging.com',
        apiKey: 'htscon_c3d9fdff123b138330f00f627d092728ea7469628c5bae1761019e5c77c2f0fed7499cd93ce3b3b3',
        apiVersion: '2025-01'
      };
      let apiEditMode = false;
      let dbConfig = {
        PORT: '4000',
        DB_HOST: '103.150.116.213',
        DB_PORT: '3306',
        DB_NAME: 'balikunewdb',
        DB_USER: 'baliku',
        DB_PASSWORD: 'Jakarta@1945'
      };
      let authUser = null;
      let appInitialized = false;
      const loginOptionsCache = {
        driver: [],
        guide: []
      };
      let currentLoginRole = 'driver';

      // Drawer logic
      btnHamburger?.addEventListener('click', () => {
        appDrawer?.classList.add('open');
        appDrawer?.setAttribute('aria-hidden','false');
      });
      btnDrawerClose?.addEventListener('click', () => {
        appDrawer?.classList.remove('open');
        appDrawer?.setAttribute('aria-hidden','true');
      });
      appDrawer?.querySelector('.overlay')?.addEventListener('click', () => {
        appDrawer?.classList.remove('open');
        appDrawer?.setAttribute('aria-hidden','true');
      });

      // Drawer menu bindings
      document.getElementById('menu-order-schedule')?.addEventListener('click', () => { appDrawer.classList.remove('open'); loadTable('operasional services', true, 'Order filters'); });
      document.getElementById('menu-services')?.addEventListener('click', () => { appDrawer.classList.remove('open'); loadTable('services', true, 'Service filters'); });
      document.getElementById('menu-driver')?.addEventListener('click', () => { appDrawer.classList.remove('open'); loadTable('driver', true, 'Filter Driver'); });
      document.getElementById('menu-guide')?.addEventListener('click', () => { appDrawer.classList.remove('open'); loadTable('guide', true, 'Filter Guide'); });
      document.getElementById('menu-car')?.addEventListener('click', () => { appDrawer.classList.remove('open'); loadTable('car', true, 'Filter Car'); });
      document.getElementById('menu-places')?.addEventListener('click', () => { appDrawer.classList.remove('open'); loadTable('places', true, 'Filter Places'); });
      document.getElementById('menu-agency')?.addEventListener('click', () => { appDrawer.classList.remove('open'); loadTable('agency', true, 'Filter Agency'); });
      document.getElementById('menu-pricelist')?.addEventListener('click', () => { appDrawer.classList.remove('open'); loadTable('pricelist', true, 'Filter Pricelist'); });
      document.getElementById('menu-pending-order')?.addEventListener('click', () => { appDrawer.classList.remove('open'); loadTable('pendings', true, 'Pending Order'); });

      async function fetchJson(path){
        statusEl.textContent = 'Loadingâ€¦';
        try{
          const headers = {};
          if(authUser?.token){
            headers['Authorization'] = `Bearer ${authUser.token}`;
          }
          const res = await fetch(API_BASE + path, { headers });
          if(!res.ok) throw new Error('HTTP ' + res.status);
          const data = await res.json();
          statusEl.textContent = '';
          return data;
        }catch(err){
          statusEl.textContent = 'Error: ' + err.message;
          throw err;
        }
      }

      const TARGET_TABLE = 'operasional services';
      const normalize = (s) => String(s).toLowerCase().replace(/_/g, ' ').trim();

      function showLoginScreen(){
        if(loginScreen){
          loginScreen.classList.remove('hidden');
          document.body.classList.add('login-active');
        }
      }

      function hideLoginScreen(){
        if(loginScreen){
          loginScreen.classList.add('hidden');
          document.body.classList.remove('login-active');
        }
      }

      function loadAuthFromStorage(){
        try{
          const raw = localStorage.getItem('balikuAuth');
          if(!raw) return null;
          const parsed = JSON.parse(raw);
          if(parsed && parsed.token && parsed.name && parsed.role){
            authUser = parsed;
            return authUser;
          }
        }catch(err){
          console.warn('Failed to parse auth data', err);
        }
        authUser = null;
        return null;
      }

      function saveAuthToStorage(){
        if(authUser){
          localStorage.setItem('balikuAuth', JSON.stringify(authUser));
        }
      }

      function clearAuthStorage(){
        localStorage.removeItem('balikuAuth');
      }

      async function startApp(){
        loadAuthFromStorage();
        if(authUser){
          hideLoginScreen();
          await initApp();
        } else {
          showLoginScreen();
          setLoginRole('driver');
        }
      }

      async function initApp(){
        if(appInitialized) return;
        await init();
        appInitialized = true;
      }

      function setLoginRole(role){
        currentLoginRole = role;
        // Update button states and checkboxes
        loginRoleButtons.forEach(btn => {
          const checkbox = btn.querySelector('.role-checkbox');
          if(btn.getAttribute('data-role') === role){
            btn.classList.add('active');
            if(checkbox) checkbox.checked = true;
          } else {
            btn.classList.remove('active');
            if(checkbox) checkbox.checked = false;
          }
        });
        if(loginNameInput){
          loginNameInput.value = '';
          loginNameInput.placeholder = 'Username';
        }
        if(loginPasswordInput){
          loginPasswordInput.value = '';
        }
        loginStatus.textContent = '';
        updateLoginButtonState();
        if(loginOptionsCache[role] && loginOptionsCache[role].length > 0){
          renderLoginOptions(role);
        } else {
          loadLoginOptions(role);
        }
      }

      function renderLoginOptions(role){
        if(!loginNameDatalist) return;
        const options = loginOptionsCache[role] || [];
        loginNameDatalist.innerHTML = options.map(name => `<option value="${escapeHtml(name)}"></option>`).join('');
      }

      async function loadLoginOptions(role){
        if(!role) return;
        try{
          if(loginStatus) loginStatus.textContent = 'Memuat daftar nama...';
          const res = await fetch(API_BASE + '/api/login/options?type=' + encodeURIComponent(role));
          if(!res.ok){
            throw new Error('HTTP ' + res.status);
          }
          const data = await res.json();
          loginOptionsCache[role] = Array.isArray(data.options) ? data.options.map(opt => opt.name).filter(Boolean) : [];
          renderLoginOptions(role);
          if(loginStatus) loginStatus.textContent = '';
        }catch(err){
          console.error('Failed to load login options:', err);
          if(loginStatus) loginStatus.textContent = 'Gagal memuat daftar nama';
        }
      }

      function updateLoginButtonState(){
        const nameFilled = loginNameInput ? loginNameInput.value.trim().length > 0 : false;
        const passFilled = loginPasswordInput ? loginPasswordInput.value.length > 0 : false;
        if(loginSubmit){
          loginSubmit.disabled = !(nameFilled && passFilled);
        }
      }

      async function handleLogin(){
        if(!loginNameInput || !loginPasswordInput) return;
        const name = loginNameInput.value.trim();
        const password = loginPasswordInput.value;
        if(!name || !password){
          if(loginStatus) loginStatus.textContent = 'Lengkapi nama dan password';
          return;
        }
        if(loginSubmit){
          loginSubmit.disabled = true;
        }
        if(loginStatus) loginStatus.textContent = 'Memverifikasi...';
        try{
          const res = await fetch(API_BASE + '/api/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ type: currentLoginRole, name, password })
          });
          let data;
          if(!res.ok){
            const errorText = await res.text();
            try{
              data = JSON.parse(errorText);
            }catch{
              data = { error: errorText || 'Login gagal' };
            }
            throw new Error(data.error || 'Login gagal');
          }
          data = await res.json();
          authUser = { role: data.role, name: data.name, token: data.token };
          saveAuthToStorage();
          hideLoginScreen();
          if(loginStatus) loginStatus.textContent = '';
          await initApp();
        }catch(err){
          console.error('Login error:', err);
          if(loginStatus) loginStatus.textContent = err.message || 'Login gagal';
        }finally{
          if(loginSubmit){
            loginSubmit.disabled = false;
          }
        }
      }

      function logoutUser(){
        clearAuthStorage();
        authUser = null;
        appInitialized = false;
        window.location.reload();
      }

      loginRoleButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          // Prevent checkbox click from triggering button click twice
          if(e.target.classList.contains('role-checkbox')){
            e.stopPropagation();
          }
          const role = btn.getAttribute('data-role');
          if(role){
            setLoginRole(role);
          }
        });
        // Also handle checkbox clicks directly
        const checkbox = btn.querySelector('.role-checkbox');
        if(checkbox){
          checkbox.addEventListener('click', (e) => {
            e.stopPropagation();
            const role = btn.getAttribute('data-role');
            if(role){
              setLoginRole(role);
            }
          });
        }
      });
      loginNameInput?.addEventListener('input', updateLoginButtonState);
      loginPasswordInput?.addEventListener('input', updateLoginButtonState);
      loginPasswordInput?.addEventListener('keydown', (e) => {
        if(e.key === 'Enter'){
          e.preventDefault();
          if(loginSubmit && !loginSubmit.disabled){
            handleLogin();
          }
        }
      });
      loginSubmit?.addEventListener('click', (e) => {
        e.preventDefault();
        handleLogin();
      });

      async function init(){
        await loadHolidayApiConfig();
        const data = await fetchJson('/api/tables');
        const tables = Array.isArray(data.tables) ? data.tables : [];
        const match = tables.find(t => normalize(t) === normalize(TARGET_TABLE));
        if(!match){
          statusEl.textContent = 'Table "operasional services" not found';
          return;
        }
        // Load with filters and rows visible by default
        await loadTable(match, true, 'Order filters');
      }

      async function ensureMeta(table){
        if(currentMeta && currentMeta.table === table) return currentMeta;
        currentMeta = await fetchJson('/api/tables/' + encodeURIComponent(table) + '/meta');
        return currentMeta;
      }

      const normName = (s) => String(s).toLowerCase().replace(/_/g,' ').trim();
      
      // Helper function to parse MySQL column type
      function parseColumnType(typeStr) {
        if (!typeStr) return { base: 'varchar', size: 255 };
        const lower = typeStr.toLowerCase();
        if (lower.includes('int')) {
          return { base: 'int', unsigned: lower.includes('unsigned') };
        }
        if (lower.includes('decimal') || lower.includes('numeric') || lower.includes('float') || lower.includes('double')) {
          const match = lower.match(/decimal\((\d+),(\d+)\)/);
          if (match) {
            return { base: 'decimal', precision: parseInt(match[1]), scale: parseInt(match[2]) };
          }
          return { base: 'decimal', precision: 10, scale: 2 };
        }
        if (lower.includes('datetime') || lower.includes('timestamp')) {
          return { base: 'datetime' };
        }
        if (lower.includes('date')) {
          return { base: 'date' };
        }
        if (lower.includes('time')) {
          return { base: 'time' };
        }
        return { base: 'varchar', size: 255 };
      }
      
      function formatDateCell(val){
        try{
          let d;

          // Handle MySQL datetime format: YYYY-MM-DD HH:mm:ss (UTC)
          if (typeof val === 'string' && val.match(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/)) {
            d = new Date(val.replace(' ', 'T') + 'Z'); // Add Z to indicate UTC
          } else {
            d = new Date(val);
          }

          if (isNaN(d)) return String(val);
          return d.toLocaleString(undefined, {
            month: 'short', day: 'numeric', year: 'numeric',
            hour: '2-digit', minute: '2-digit', hour12: true
          });
        }catch{ return String(val); }
      }

      function formatDateOnly(val){
        try{
          let d;

          // Handle MySQL datetime format: YYYY-MM-DD HH:mm:ss (UTC)
          if (typeof val === 'string' && val.match(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/)) {
            d = new Date(val.replace(' ', 'T') + 'Z'); // Add Z to indicate UTC
          } else {
            d = new Date(val);
          }

          if (isNaN(d)) return String(val);
          return d.toLocaleString(undefined, {
            month: 'short', day: 'numeric', year: 'numeric'
          });
        }catch{ return String(val); }
      }
      
      function formatNumberCell(val) {
        if (val === null || val === undefined || val === '') return '';
        const num = Number(val);
        if (isNaN(num)) return String(val);
        // Format with thousand separators
        return num.toLocaleString();
      }

      function toDatetimeLocalValue(val){
        try{
          console.log('toDatetimeLocalValue input:', val, typeof val);
          let d;

          // Handle MySQL datetime format: YYYY-MM-DD HH:mm:ss (UTC)
          if (typeof val === 'string' && val.match(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/)) {
            // Parse as UTC datetime
            d = new Date(val.replace(' ', 'T') + 'Z');
            console.log('Parsed UTC datetime:', d);
          } else {
            d = new Date(val);
            console.log('Parsed other datetime:', d);
          }

          if (isNaN(d)) {
            console.log('Invalid date, returning empty string');
            return '';
          }

          // Convert to local time for datetime-local input
          const pad = (n) => String(n).padStart(2,'0');
          const yyyy = d.getFullYear();
          const mm = pad(d.getMonth()+1);
          const dd = pad(d.getDate());
          const hh = pad(d.getHours());
          const mi = pad(d.getMinutes());
          const result = `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
          console.log('toDatetimeLocalValue result:', result);
          return result;
        }catch(e){
          console.log('toDatetimeLocalValue error:', e);
          return '';
        }
      }

      function formatCell(columnName, value){
        const n = normName(columnName);
        // Check if it's a date field (by name or type)
        if (
          n === normName('Date of Services') ||
          n === normName('Driver Service Time') ||
          n === normName('Timestamps') ||
          n === normName('Booking Date')
        ){
          return formatDateCell(value);
        }
        // Check column type for date/datetime
        if (currentMeta?.columnTypes?.[columnName]) {
          const colType = parseColumnType(currentMeta.columnTypes[columnName]);
          if (colType.base === 'datetime' || colType.base === 'date' || colType.base === 'timestamp') {
            return formatDateCell(value);
          }
        }

        if (THOUSAND_SEPARATOR_COLUMNS.some(col => normName(col) === n)) {
          return formatNumberCell(value);
        }
        return String(value);
      }

      const VISIBLE_HEADERS = ['Service Status','Services','Program/Activity','Flight Details','Date of Services'];
      const SERVICES_VISIBLE_HEADERS = ['Guest Name','Agency','Reference No.','Flight Details','Start Point','End Point','Date Of Services','Service Status'];
      const THOUSAND_SEPARATOR_COLUMNS = [
        'Service Rate',
        'Nett Rate',
        'Guide Fee',
        'Guide Commision',
        'Driver Fee',
        'BBM',
        'Ticket'
      ];

      // Table grouping configuration
      const TABLE_GROUPING = {
        'operasional services': { column: 'Date of Services', type: 'date' },
        'services': { column: 'Date Of Services', type: 'date' },
        'driver': { column: 'Driver Status', type: 'text' },
        'guide': { column: 'Address', type: 'text' },
        'car': { column: 'Car Type', type: 'text' },
        'places': { column: 'Zone', type: 'text' },
        'program activity': { column: 'Provider', type: 'text' },
        'pendings': { column: 'StatusCode', type: 'text' }
      };

      function renderRows(rows){
        if(rows.length === 0){
          rowsEl.innerHTML = '<tr><td class="muted">No rows</td></tr>';
          rowsCard.style.display = 'block';
          return;
        }
        const allCols = Object.keys(rows[0]);
        // Only filter columns for "operasional services" table, show all for others
        const isOperasionalServices = currentTable && normalize(currentTable) === normalize(TARGET_TABLE);
        let cols, headerHtml;

        const isServicesTable = currentTable && normalize(currentTable) === 'services';

        if(isOperasionalServices){
          // For operasional services, show only selected columns
          cols = VISIBLE_HEADERS.map(h => allCols.find(k => normName(k) === normName(h))).filter(Boolean);
          headerHtml = VISIBLE_HEADERS.filter(h => cols.find(c => normName(c) === normName(h)) ).map(h=>`<th>${h}</th>`).join('');
        } else if(isServicesTable){
          // For services table, show only selected columns
          cols = SERVICES_VISIBLE_HEADERS.map(h => allCols.find(k => normName(k) === normName(h))).filter(Boolean);
          headerHtml = SERVICES_VISIBLE_HEADERS.filter(h => cols.find(c => normName(c) === normName(h)) ).map(h=>`<th>${h}</th>`).join('');
        } else {
          // For all other tables, show all columns
          cols = allCols;
          headerHtml = allCols.map(c => `<th>${c}</th>`).join('');
        }
        const actionHeader = '<th>Action</th>';
        let html = '<thead><tr>' + actionHeader + headerHtml + '</tr></thead><tbody>';

        // Check if this table should be grouped
        const tableGrouping = TABLE_GROUPING[normalize(currentTable)];

        if(tableGrouping){
          // Group rows by the specified column
          const groupCol = Object.keys(rows[0] || {}).find(k => normName(k) === normName(tableGrouping.column));

          if(groupCol){
            // Group rows by the grouping column
            const groupedRows = {};
            rows.forEach(row => {
              let groupKey = String(row[groupCol] || 'No Value');

              if(tableGrouping.type === 'date' && groupKey.match(/^\d{4}-\d{2}-\d{2}/)) {
                // For date grouping, extract date part only (ignore time)
                let rowDate;
                if (typeof row[groupCol] === 'string' && row[groupCol].match(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/)) {
                  rowDate = new Date(row[groupCol].replace(' ', 'T') + 'Z');
                } else {
                  rowDate = new Date(row[groupCol]);
                }

                if (!isNaN(rowDate)) {
                  const pad = (n) => String(n).padStart(2,'0');
                  groupKey = `${rowDate.getFullYear()}-${pad(rowDate.getMonth()+1)}-${pad(rowDate.getDate())}`;
                }
              }

              if (!groupedRows[groupKey]) {
                groupedRows[groupKey] = [];
              }
              groupedRows[groupKey].push(row);
            });

            // Sort group keys (for date groups, sort by date descending; for text groups, sort alphabetically)
            let sortedGroupKeys;
            if(tableGrouping.type === 'date'){
              sortedGroupKeys = Object.keys(groupedRows).sort((a, b) => new Date(b) - new Date(a));
            } else {
              sortedGroupKeys = Object.keys(groupedRows).sort();
            }

            // Render grouped rows with headers
            sortedGroupKeys.forEach(groupKey => {
              const groupRows = groupedRows[groupKey];
              let displayGroupName = groupKey;

              // Format the group name for display
              if (tableGrouping.type === 'date' && groupKey && groupRows.length > 0) {
                const sampleValue = groupRows[0][groupCol];
                displayGroupName = formatDateOnly(sampleValue);
              } else if (groupKey === 'No Value') {
                displayGroupName = 'No ' + tableGrouping.column;
              }

              // Add group header
              html += `<tr class="group-header"><td colspan="${cols.length + 1}" class="group-header-cell">${displayGroupName} (${groupRows.length} record${groupRows.length > 1 ? 's' : ''})</td></tr>`;

              // Add rows for this group
              groupRows.forEach(r => {
                const cells = cols.map(c => `<td>${formatCell(c, r[c])}</td>`).join('');
                const actionCell = `<td><button data-details='${encodeURIComponent(JSON.stringify(r))}' title="Show Details"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"/></svg></button></td>`;
                html += '<tr>' + actionCell + cells + '</tr>';
              });
            });
          } else {
            // Fallback to regular rendering if grouping column not found
            for(const r of rows){
              const cells = cols.map(c => `<td>${formatCell(c, r[c])}</td>`).join('');
              const actionCell = `<td><button data-details='${encodeURIComponent(JSON.stringify(r))}' title="Show Details"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"/></svg></button></td>`;
              html += '<tr>' + actionCell + cells + '</tr>';
            }
          }
        } else {
          // Regular rendering for tables without grouping
          for(const r of rows){
            const cells = cols.map(c => `<td>${formatCell(c, r[c])}</td>`).join('');
            const actionCell = `<td><button data-details='${encodeURIComponent(JSON.stringify(r))}' title="Show Details"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"/></svg></button></td>`;
            html += '<tr>' + actionCell + cells + '</tr>';
          }
        }

        html += '</tbody>';
        rowsEl.innerHTML = html;
        rowsCard.style.display = 'block';

        rowsEl.querySelectorAll('button[data-details]').forEach(btn => {
          btn.addEventListener('click', () => {
            const data = JSON.parse(decodeURIComponent(btn.getAttribute('data-details')));
            showDetails(data);
          });
        });
      }

      function findDateOfServicesColumn(row){
        if(!row) return null;
        const keys = Object.keys(row);
        const dateCol = keys.find(k => normName(k) === normName('Date of Services'));
        return dateCol || null;
      }

      function findColumnByName(row, targetName){
        if(!row) return null;
        const keys = Object.keys(row);
        return keys.find(k => normName(k) === normName(targetName)) || null;
      }

      function applyFilters(){
        const searchTerm = (searchFilter?.value || '').toLowerCase().trim();
        const checkbox48Hours = document.getElementById('checkbox-48-hours');
        const checkbox7Days = document.getElementById('checkbox-7-days');
        const checkboxPcon = document.getElementById('checkbox-pcon');
        const checkboxPamm = document.getElementById('checkbox-pamm');
        const checkboxPcan = document.getElementById('checkbox-pcan');
        const check48Hours = checkbox48Hours?.checked || false;
        const check7Days = checkbox7Days?.checked || false;
        const checkPcon = checkboxPcon?.checked || false;
        const checkPamm = checkboxPamm?.checked || false;
        const checkPcan = checkboxPcan?.checked || false;
        
        let rows = originalRows.slice();
        
        // Apply date filter only for "operasional services" and "services" tables
        const isOperasionalServices = currentTable && normalize(currentTable) === normalize(TARGET_TABLE);
        const isServicesTable = currentTable && normalize(currentTable) === 'services';
        const isPendingsTable = currentTable && normalize(currentTable) === 'pendings';
        console.log('[DEBUG] Table check:', { currentTable, isOperasionalServices, isServicesTable, isPendingsTable, check48Hours, check7Days, checkPcon, checkPamm, checkPcan, rowsLength: rows.length });

        if((isOperasionalServices || isServicesTable) && (check48Hours || check7Days) && rows.length > 0){
          console.log('[DEBUG] Date filtering for table:', currentTable);
          const dateCol = isOperasionalServices ? findDateOfServicesColumn(rows[0]) :
                        isServicesTable ? Object.keys(rows[0] || {}).find(k => normName(k) === 'date of services') : null;
          console.log('[DEBUG] Found date column:', dateCol);
          console.log('[DEBUG] Available columns:', Object.keys(rows[0] || {}));
          console.log('[DEBUG] Normalized available columns:', Object.keys(rows[0] || {}).map(k => normName(k)));
          if(dateCol){
            console.log('[DEBUG] Starting date filtering...');
            const startRange = new Date();
            startRange.setHours(0, 0, 0, 0); // beginning of today

            let endRange = null;
            if(check7Days){
              endRange = new Date(startRange);
              endRange.setDate(endRange.getDate() + 7);
              endRange.setHours(23, 59, 59, 999);
              console.log('[DEBUG] Filter range: 7 days -', startRange.toISOString(), 'to', endRange.toISOString());
            } else if(check48Hours){
              endRange = new Date(startRange);
              endRange.setDate(endRange.getDate() + 1);
              endRange.setHours(23, 59, 59, 999);
              console.log('[DEBUG] Filter range: 48 hours -', startRange.toISOString(), 'to', endRange.toISOString());
            }

            if(endRange){
              rows = rows.filter((row, index) => {
                const rawValue = row[dateCol];
                console.log(`[DEBUG] Processing row ${index + 1}: "${rawValue}"`);

                if(!rawValue) {
                  console.log(`[DEBUG] EXCLUDED - No value`);
                  return false;
                }

                let rowDate;
                if (typeof rawValue === 'string' && rawValue.match(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/)) {
                  // Handle MySQL datetime format: YYYY-MM-DD HH:mm:ss (stored as UTC)
                  rowDate = new Date(rawValue.replace(' ', 'T') + 'Z'); // Parse as UTC
                } else {
                  rowDate = new Date(rawValue);
                }

                console.log(`[DEBUG] Parsed date:`, rowDate.toISOString(), `Is valid: ${!isNaN(rowDate)}`);

                if(isNaN(rowDate)) {
                  console.log(`[DEBUG] EXCLUDED - Invalid date`);
                  return false;
                }

                const isInRange = rowDate >= startRange && rowDate <= endRange;
                console.log(`[DEBUG] ${isInRange ? 'INCLUDED' : 'EXCLUDED'} - ${rowDate >= startRange ? 'â‰¥ start' : '< start'} && ${rowDate <= endRange ? 'â‰¤ end' : '> end'}`);

                return isInRange;
              });

              console.log(`[DEBUG] Filtered ${rows.length} rows out of ${originalRows.length} total rows`);
            } else {
              console.log('[DEBUG] No date column found for filtering');
            }
          }
        }
        
        // Apply StatusCode filter for "pendings" table
        if(isPendingsTable && (checkPcon || checkPamm || checkPcan) && rows.length > 0){
          const statusCodeCol = Object.keys(rows[0] || {}).find(k => normName(k) === normName('StatusCode'));
          if(statusCodeCol){
            rows = rows.filter(row => {
              const statusCode = String(row[statusCodeCol] || '').trim();
              if(checkPcon && statusCode === 'PCON') return true;
              if(checkPamm && statusCode === 'PAMM') return true;
              if(checkPcan && statusCode === 'PCAN') return true;
              return false;
            });
          }
        }
        
        // Restrict driver/guide tables based on logged-in user
        if(authUser && rows.length > 0){
          if(authUser.role === 'driver' && currentTable && normalize(currentTable) === 'driver'){
            const driverNameCol = Object.keys(rows[0] || {}).find(k => normName(k) === normName('Driver Name'));
            if(driverNameCol){
              const targetName = String(authUser.name || '').trim().toLowerCase();
              rows = rows.filter(row => String(row[driverNameCol] || '').trim().toLowerCase() === targetName);
            }
          } else if(authUser.role === 'guide' && currentTable && normalize(currentTable) === 'guide'){
            const guideNameCol = Object.keys(rows[0] || {}).find(k => normName(k) === normName('Guide Name'));
            if(guideNameCol){
              const targetName = String(authUser.name || '').trim().toLowerCase();
              rows = rows.filter(row => String(row[guideNameCol] || '').trim().toLowerCase() === targetName);
            }
          }
        }
        
        // Apply search filter
        if(searchTerm){
          rows = rows.filter(row => {
            return Object.values(row).some(val => {
              return String(val).toLowerCase().includes(searchTerm);
            });
          });
        }
        
        renderRows(rows);
      }

      async function loadRows(table){
        const data = await fetchJson('/api/tables/' + encodeURIComponent(table) + '?limit=200');
        rowsTitle.textContent = 'Rows: ' + table;
        originalRows = data.rows || [];
        if(searchFilter) searchFilter.value = ''; // Clear search on new table load
        // Uncheck date filters when loading new table
        const checkbox48Hours = document.getElementById('checkbox-48-hours');
        const checkbox7Days = document.getElementById('checkbox-7-days');
        if(checkbox48Hours) checkbox48Hours.checked = false;
        if(checkbox7Days) checkbox7Days.checked = false;
        
        // Show/hide Import CSV button based on table
        const allowedTables = ['pendings', 'operasional services'];
        const isAllowed = allowedTables.some(t => normalize(t) === normalize(table));
        if(importCsvBtn) {
          importCsvBtn.style.display = isAllowed ? '' : 'none';
        }
        
        applyFilters();
      }

      searchFilter?.addEventListener('input', applyFilters);
      document.getElementById('checkbox-48-hours')?.addEventListener('change', applyFilters);
      document.getElementById('checkbox-7-days')?.addEventListener('change', applyFilters);
      document.getElementById('checkbox-pcon')?.addEventListener('change', applyFilters);
      document.getElementById('checkbox-pamm')?.addEventListener('change', applyFilters);
      document.getElementById('checkbox-pcan')?.addEventListener('change', applyFilters);
      startApp();

      function escapeHtml(s){
        return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
      }

      let carTypesCache = null;
      let driverNamesCache = null;
      let guideNamesCache = null;

      async function loadCarTypes(){
        if(carTypesCache) return carTypesCache;
        try {
          const data = await fetchJson('/api/tables/' + encodeURIComponent('car') + '?limit=1000');
          const rows = data.rows || [];
          const carTypes = new Set();
          rows.forEach(row => {
            const carTypeInfo = row['Car_type_info'] || row['car_type_info'] || row['Car Type Info'];
            if(carTypeInfo && String(carTypeInfo).trim()){
              carTypes.add(String(carTypeInfo).trim());
            }
          });
          carTypesCache = Array.from(carTypes).sort();
          return carTypesCache;
        } catch(err) {
          console.error('Failed to load car types:', err);
          return [];
        }
      }

      async function loadDriverNames(){
        if(driverNamesCache) return driverNamesCache;
        try {
          const data = await fetchJson('/api/tables/' + encodeURIComponent('driver') + '?limit=1000');
          const rows = data.rows || [];
          const driverNames = new Set();
          rows.forEach(row => {
            const driverDetails = row['driver_details'] || row['Driver_details'] || row['Driver Details'];
            if(driverDetails && String(driverDetails).trim()){
              driverNames.add(String(driverDetails).trim());
            }
          });
          driverNamesCache = Array.from(driverNames).sort();
          return driverNamesCache;
        } catch(err) {
          console.error('Failed to load driver names:', err);
          return [];
        }
      }

      async function loadGuideNames(){
        if(guideNamesCache) return guideNamesCache;
        try {
          const data = await fetchJson('/api/tables/' + encodeURIComponent('guide') + '?limit=1000');
          const rows = data.rows || [];
          const guideNames = new Set();
          rows.forEach(row => {
            const guideDetails = row['guide_details'] || row['Guide_details'] || row['Guide Details'];
            if(guideDetails && String(guideDetails).trim()){
              guideNames.add(String(guideDetails).trim());
            }
          });
          guideNamesCache = Array.from(guideNames).sort();
          return guideNamesCache;
        } catch(err) {
          console.error('Failed to load guide names:', err);
          return [];
        }
      }

      async function renderDetails(row){
        const keys = Object.keys(row);
        const pkSet = new Set((currentMeta?.primaryKey)||[]);
        const generatedColumnsSet = new Set((currentMeta?.generatedColumns)||[]);
        
        // Check if we need car types, driver names, or guide names for searchable dropdowns
        const isOperasionalServices = currentTable && normalize(currentTable) === normalize(TARGET_TABLE);
        const needsCarTypes = isOperasionalServices && (editMode || addMode) && 
          keys.some(k => normName(k) === normName('Car Type'));
        const needsDriverNames = isOperasionalServices && (editMode || addMode) && 
          keys.some(k => normName(k) === normName('Driver Name'));
        const needsGuideNames = isOperasionalServices && (editMode || addMode) && 
          keys.some(k => normName(k) === normName('Guide Name'));
        
        let carTypes = [];
        let driverNames = [];
        let guideNames = [];
        if(needsCarTypes){
          carTypes = await loadCarTypes();
        }
        if(needsDriverNames){
          driverNames = await loadDriverNames();
        }
        if(needsGuideNames){
          guideNames = await loadGuideNames();
        }
        
        const html = keys.map(k => {
          const v = row[k];
          const isGenerated = generatedColumnsSet.has(k);
          
          // Determine field type from column metadata or field name
          let fieldType = null;
          let isDateLike = false;
          let isNumeric = false;
          let numericConfig = { step: '1', min: '' };
          
          if (currentMeta?.columnTypes?.[k]) {
            const colType = parseColumnType(currentMeta.columnTypes[k]);
            if (colType.base === 'datetime' || colType.base === 'timestamp') {
              isDateLike = true;
              fieldType = 'datetime-local';
            } else if (colType.base === 'date') {
              isDateLike = true;
              fieldType = 'date';
            } else if (colType.base === 'time') {
              isDateLike = true;
              fieldType = 'time';
            } else if (colType.base === 'int') {
              isNumeric = true;
              fieldType = 'number';
              numericConfig.step = '1';
              // Don't set min for all ints - some might be negative (like IDs can be)
              // Only set min for unsigned ints if we detect it
              if (colType.unsigned) {
                numericConfig.min = '0';
              }
            } else if (colType.base === 'decimal') {
              isNumeric = true;
              fieldType = 'number';
              // For decimal(10, 0), step should be 1, otherwise use decimal step
              if (colType.scale === 0) {
                numericConfig.step = '1';
              } else {
                numericConfig.step = '0.' + '0'.repeat(colType.scale - 1) + '1';
              }
              numericConfig.min = '';
            }
          } else {
            // Fallback: check by field name
            const n = normName(k);
            if (
              n === normName('Date of Services') ||
              n === normName('Driver Service Time') ||
              n === normName('Timestamps') ||
              n === normName('Booking Date')
            ) {
              isDateLike = true;
              fieldType = 'datetime-local';
            }
          }
        
          if((editMode || addMode) && !pkSet.has(k) && !isGenerated){
            if(isDateLike && fieldType){
              let dateValue = '';
              if (fieldType === 'datetime-local') {
                dateValue = toDatetimeLocalValue(v);
              } else if (fieldType === 'date') {
                try {
                  let d;
                  // Handle MySQL datetime format: YYYY-MM-DD HH:mm:ss (UTC)
                  if (typeof v === 'string' && v.match(/^\d{4}-\d{2}-\d{2}/)) {
                    if (v.includes(' ')) {
                      d = new Date(v.replace(' ', 'T') + 'Z'); // Parse as UTC
                    } else {
                      d = new Date(v + 'T00:00:00Z'); // Date only, assume midnight UTC
                    }
                  } else {
                    d = new Date(v);
                  }
                  if (!isNaN(d)) {
                    const pad = (n) => String(n).padStart(2,'0');
                    dateValue = `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
                  }
                } catch {}
              } else if (fieldType === 'time') {
                try {
                  let d;
                  // Handle MySQL datetime format: YYYY-MM-DD HH:mm:ss (UTC)
                  if (typeof v === 'string' && v.match(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/)) {
                    d = new Date(v.replace(' ', 'T') + 'Z'); // Parse as UTC
                  } else {
                    d = new Date(v);
                  }
                  if (!isNaN(d)) {
                    const pad = (n) => String(n).padStart(2,'0');
                    dateValue = `${pad(d.getHours())}:${pad(d.getMinutes())}`;
                  }
                } catch {}
              }
              console.log(`Creating ${fieldType} input for ${k}: original value =`, v, `converted value =`, dateValue);
              return `<div class="kv"><div class="muted">${escapeHtml(k)}</div><div><input type="${fieldType}" data-field="${escapeHtml(k)}" value="${escapeHtml(dateValue)}" style="width:100%;padding:8px;border-radius:8px;border:1px solid #1f2a44;background:#0b1225;color:#e6edf3" /></div></div>`;
            } else if(isNumeric && fieldType === 'number'){
              let numValue = v !== null && v !== undefined ? Number(v) : '';

              // Auto-fill default value 0 for integer columns if empty/null
              if (currentMeta?.columnTypes?.[k]) {
                const colType = parseColumnType(currentMeta.columnTypes[k]);
                if (colType.base === 'int' && (v === null || v === undefined || v === '' || isNaN(numValue))) {
                  numValue = 0;
                }
              }

              const stepAttr = numericConfig.step ? ` step="${escapeHtml(numericConfig.step)}"` : '';
              const minAttr = numericConfig.min !== '' ? ` min="${escapeHtml(numericConfig.min)}"` : '';
              return `<div class="kv"><div class="muted">${escapeHtml(k)}</div><div><input type="number" data-field="${escapeHtml(k)}" value="${numValue}"${stepAttr}${minAttr} style="width:100%;padding:8px;border-radius:8px;border:1px solid #1f2a44;background:#0b1225;color:#e6edf3" /></div></div>`;
            } else {
              // Check if this is "Car Type", "Driver Name", or "Guide Name" field in "operasional services" table
              const isCarTypeField = isOperasionalServices && normName(k) === normName('Car Type');
              const isDriverNameField = isOperasionalServices && normName(k) === normName('Driver Name');
              const isGuideNameField = isOperasionalServices && normName(k) === normName('Guide Name');
              
              if(isCarTypeField && carTypes.length > 0){
                const currentValue = String(v ?? '');
                const fieldId = `car-type-${k.replace(/\s+/g, '-').toLowerCase()}`;
                const options = carTypes.map(ct => {
                  return `<div class="dropdown-option" data-value="${escapeHtml(ct)}">${escapeHtml(ct)}</div>`;
                }).join('');
                return `<div class="kv"><div class="muted">${escapeHtml(k)}</div><div style="position:relative"><input type="text" id="${fieldId}" data-field="${escapeHtml(k)}" data-dropdown="car-type" value="${escapeHtml(currentValue)}" placeholder="Type to search car type..." autocomplete="off" style="width:100%;padding:8px;border-radius:8px;border:1px solid #1f2a44;background:#0b1225;color:#e6edf3" /><div class="dropdown-list" id="${fieldId}-dropdown" style="display:none;position:absolute;top:100%;left:0;right:0;max-height:200px;overflow-y:auto;background:#0f172a;border:1px solid #1f2a44;border-radius:8px;margin-top:4px;z-index:1000;box-shadow:0 4px 12px rgba(0,0,0,.3)">${options}</div></div></div>`;
              } else if(isDriverNameField && driverNames.length > 0){
                const currentValue = String(v ?? '');
                const fieldId = `driver-name-${k.replace(/\s+/g, '-').toLowerCase()}`;
                const options = driverNames.map(dn => {
                  return `<div class="dropdown-option" data-value="${escapeHtml(dn)}">${escapeHtml(dn)}</div>`;
                }).join('');
                return `<div class="kv"><div class="muted">${escapeHtml(k)}</div><div style="position:relative"><input type="text" id="${fieldId}" data-field="${escapeHtml(k)}" data-dropdown="driver-name" value="${escapeHtml(currentValue)}" placeholder="Type to search driver name..." autocomplete="off" style="width:100%;padding:8px;border-radius:8px;border:1px solid #1f2a44;background:#0b1225;color:#e6edf3" /><div class="dropdown-list" id="${fieldId}-dropdown" style="display:none;position:absolute;top:100%;left:0;right:0;max-height:200px;overflow-y:auto;background:#0f172a;border:1px solid #1f2a44;border-radius:8px;margin-top:4px;z-index:1000;box-shadow:0 4px 12px rgba(0,0,0,.3)">${options}</div></div></div>`;
              } else if(isGuideNameField && guideNames.length > 0){
                const currentValue = String(v ?? '');
                const fieldId = `guide-name-${k.replace(/\s+/g, '-').toLowerCase()}`;
                const options = guideNames.map(gn => {
                  return `<div class="dropdown-option" data-value="${escapeHtml(gn)}">${escapeHtml(gn)}</div>`;
                }).join('');
                return `<div class="kv"><div class="muted">${escapeHtml(k)}</div><div style="position:relative"><input type="text" id="${fieldId}" data-field="${escapeHtml(k)}" data-dropdown="guide-name" value="${escapeHtml(currentValue)}" placeholder="Type to search guide name..." autocomplete="off" style="width:100%;padding:8px;border-radius:8px;border:1px solid #1f2a44;background:#0b1225;color:#e6edf3" /><div class="dropdown-list" id="${fieldId}-dropdown" style="display:none;position:absolute;top:100%;left:0;right:0;max-height:200px;overflow-y:auto;background:#0f172a;border:1px solid #1f2a44;border-radius:8px;margin-top:4px;z-index:1000;box-shadow:0 4px 12px rgba(0,0,0,.3)">${options}</div></div></div>`;
              } else {
                const inputValue = String(v ?? '');
                return `<div class="kv"><div class="muted">${escapeHtml(k)}</div><div><input type="text" data-field="${escapeHtml(k)}" value="${escapeHtml(inputValue)}" style="width:100%;padding:8px;border-radius:8px;border:1px solid #1f2a44;background:#0b1225;color:#e6edf3" /></div></div>`;
              }
            }
          } else {
            const display = formatCell(k, v);
            const readonly = pkSet.has(k) && editMode ? ' (primary key)' : '';
            return `<div class="kv"><div class="muted">${escapeHtml(k)}${readonly}</div><div>${escapeHtml(display)}</div></div>`;
          }
        });
        detailsContent.innerHTML = html.join('') || '<div class="muted">No details</div>';
        
        // Initialize searchable dropdowns for Car Type, Driver Name, and Guide Name fields
        if(isOperasionalServices && (editMode || addMode)){
          initializeSearchableDropdowns();
        }
      }

      function initializeSearchableDropdowns(){
        // Initialize all searchable dropdowns (car-type, driver-name, guide-name)
        const dropdownInputs = detailsContent.querySelectorAll('input[data-dropdown]');
        dropdownInputs.forEach(input => {
          const dropdownId = input.id + '-dropdown';
          const dropdown = document.getElementById(dropdownId);
          if(!dropdown) return;
          
          let isDropdownOpen = false;
          
          // Show dropdown on focus or when typing
          input.addEventListener('focus', () => {
            filterDropdownOptions(input, dropdown);
            dropdown.style.display = 'block';
            isDropdownOpen = true;
          });
          
          input.addEventListener('input', () => {
            filterDropdownOptions(input, dropdown);
            dropdown.style.display = 'block';
            isDropdownOpen = true;
          });
          
          // Handle option selection
          dropdown.querySelectorAll('.dropdown-option').forEach(option => {
            option.addEventListener('click', () => {
              const value = option.getAttribute('data-value');
              input.value = value;
              dropdown.style.display = 'none';
              isDropdownOpen = false;
              input.blur();
            });
          });
          
          // Close dropdown when clicking outside
          document.addEventListener('click', (e) => {
            if(isDropdownOpen && !input.contains(e.target) && !dropdown.contains(e.target)){
              dropdown.style.display = 'none';
              isDropdownOpen = false;
            }
          });
          
          // Handle keyboard navigation
          let highlightedIndex = -1;
          input.addEventListener('keydown', (e) => {
            const options = Array.from(dropdown.querySelectorAll('.dropdown-option:not([style*="display:none"])'));
            
            if(e.key === 'ArrowDown'){
              e.preventDefault();
              highlightedIndex = Math.min(highlightedIndex + 1, options.length - 1);
              updateHighlight(options, highlightedIndex);
              if(options[highlightedIndex]){
                options[highlightedIndex].scrollIntoView({ block: 'nearest' });
              }
            } else if(e.key === 'ArrowUp'){
              e.preventDefault();
              highlightedIndex = Math.max(highlightedIndex - 1, -1);
              updateHighlight(options, highlightedIndex);
              if(options[highlightedIndex]){
                options[highlightedIndex].scrollIntoView({ block: 'nearest' });
              }
            } else if(e.key === 'Enter' && highlightedIndex >= 0 && options[highlightedIndex]){
              e.preventDefault();
              options[highlightedIndex].click();
            } else if(e.key === 'Escape'){
              dropdown.style.display = 'none';
              isDropdownOpen = false;
              input.blur();
            }
          });
        });
      }

      function filterDropdownOptions(input, dropdown){
        const searchTerm = input.value.toLowerCase().trim();
        const options = dropdown.querySelectorAll('.dropdown-option');
        let visibleCount = 0;
        
        options.forEach(option => {
          const value = option.getAttribute('data-value').toLowerCase();
          if(value.includes(searchTerm)){
            option.style.display = 'block';
            visibleCount++;
          } else {
            option.style.display = 'none';
          }
        });
        
        // Show dropdown only if there are visible options
        if(visibleCount === 0 && searchTerm === ''){
          dropdown.style.display = 'block';
        } else if(visibleCount === 0){
          dropdown.style.display = 'none';
        }
      }

      function updateHighlight(options, index){
        options.forEach((opt, i) => {
          if(i === index){
            opt.classList.add('highlight');
          } else {
            opt.classList.remove('highlight');
          }
        });
      }

      async function showDetails(row){
        // Stop tracking previous row if switching to a different row
        if(currentRow && currentRow !== row){
          const prevBookingRefCol = findColumnByName(currentRow, 'Reference No.');
          const newBookingRefCol = findColumnByName(row, 'Reference No.');
          if(prevBookingRefCol && newBookingRefCol){
            const prevRef = currentRow[prevBookingRefCol];
            const newRef = row[newBookingRefCol];
            if(prevRef !== newRef){
              // Different booking, stop previous tracking
              stopLocationTracking();
            }
          }
        }
        
        currentRow = row;
        editMode = false;
        addMode = false;
        detailsModalTitle.textContent = 'Row Details';
        detailsEdit.style.display = '';
        detailsSave.style.display = 'none';
        detailsCancel.style.display = 'none';
        detailsDelete.style.display = '';
        if(buttonsContainer){
          if(currentTable && normalize(currentTable) === normalize(TARGET_TABLE)){
            buttonsContainer.style.display = 'flex';
            if(statusButtonsSection) statusButtonsSection.style.display = 'flex';
            if(htxActionsSection) htxActionsSection.style.display = 'flex';
          } else {
            buttonsContainer.style.display = 'none';
            if(statusButtonsSection) statusButtonsSection.style.display = 'none';
            if(htxActionsSection) htxActionsSection.style.display = 'none';
          }
        }
        if(pendingButtonsSection){
          if(currentTable && normalize(currentTable) === 'pendings'){
            pendingButtonsSection.style.display = 'flex';
          } else {
            pendingButtonsSection.style.display = 'none';
          }
        }
        await renderDetails(row);
        detailsModal.classList.add('open');
        detailsModal.setAttribute('aria-hidden','false');
      }

      async function saveDetails(){
        if(!currentRow || !currentTable) return;
        try {
          await ensureMeta(currentTable);
          const pkCols = currentMeta.primaryKey || [];
          if(pkCols.length === 0){
            alert('Cannot update: table has no primary key');
            return;
          }
          const key = {};
          for(const c of pkCols){ key[c] = currentRow[c]; }
          const inputs = detailsContent.querySelectorAll('input[data-field], select[data-field]');
          const data = {};
          const generatedColumnsSet = new Set((currentMeta?.generatedColumns)||[]);
          
          inputs.forEach(inp => {
            const field = inp.getAttribute('data-field');
            // Skip generated/virtual columns - they cannot be updated
            if(generatedColumnsSet.has(field)){
              return;
            }
            const inputType = inp.type || (inp.tagName === 'SELECT' ? 'select' : 'text');
            let value = inp.value;

            // First, check column type and convert based on that (more reliable than input type)
            if (currentMeta?.columnTypes?.[field]) {
              const colType = parseColumnType(currentMeta.columnTypes[field]);
              if (colType.base === 'int') {
                if (value === '' || value === null || value === undefined) {
                  value = 0;
                } else {
                  const numVal = Number(value);
                  if (isNaN(numVal)) {
                    alert(`Invalid integer value for field "${field}". Please enter a valid number.`);
                    throw new Error('Invalid integer');
                  }
                  value = Math.floor(numVal);
                }
              } else if (colType.base === 'decimal') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else {
                  const numVal = Number(value);
                  if (isNaN(numVal)) {
                    alert(`Invalid decimal value for field "${field}". Please enter a valid number.`);
                    throw new Error('Invalid decimal');
                  }
                  value = numVal;
                }
              } else if (colType.base === 'datetime' || colType.base === 'timestamp') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else if (inputType === 'datetime-local') {
                  // datetime-local format: YYYY-MM-DDTHH:mm (local time)
                  // Convert to UTC for MySQL storage
                  const date = new Date(value);
                  if (isNaN(date.getTime())) {
                    alert(`Invalid date/time value for field "${field}". Please enter a valid date and time.`);
                    throw new Error('Invalid datetime');
                  }
                  // Format as MySQL datetime in UTC: YYYY-MM-DD HH:mm:ss
                  const pad = (n) => String(n).padStart(2,'0');
                  value = `${date.getUTCFullYear()}-${pad(date.getUTCMonth()+1)}-${pad(date.getUTCDate())} ${pad(date.getUTCHours())}:${pad(date.getUTCMinutes())}:${pad(date.getUTCSeconds())}`;
                }
              } else if (colType.base === 'date') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else if (inputType === 'date') {
                  // date format: YYYY-MM-DD (local date input)
                  // Convert to UTC date for MySQL storage
                  const date = new Date(value + 'T00:00:00');
                  if (isNaN(date.getTime())) {
                    alert(`Invalid date value for field "${field}". Please enter a valid date.`);
                    throw new Error('Invalid date');
                  }
                  const pad = (n) => String(n).padStart(2,'0');
                  value = `${date.getUTCFullYear()}-${pad(date.getUTCMonth()+1)}-${pad(date.getUTCDate())}`;
                }
              } else if (colType.base === 'time') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else if (inputType === 'time') {
                  // time format: HH:mm (local time input)
                  // For time fields, we typically store as-is since MySQL TIME doesn't have timezone
                  value = value + ':00'; // Add seconds
                }
              }
            } else {
              // Fallback: convert based on input type if no column type info
              if (inputType === 'number') {
                if (value === '' || value === null || value === undefined) {
                  value = 0;
                } else {
                  const numVal = Number(value);
                  if (isNaN(numVal)) {
                    alert(`Invalid number value for field "${field}". Please enter a valid number.`);
                    throw new Error('Invalid number');
                  }
                  value = numVal;
                }
              } else if (inputType === 'datetime-local') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else {
                  const date = new Date(value);
                  if (isNaN(date.getTime())) {
                    alert(`Invalid date/time value for field "${field}". Please enter a valid date and time.`);
                    throw new Error('Invalid datetime');
                  }
                  const pad = (n) => String(n).padStart(2,'0');
                  value = `${date.getUTCFullYear()}-${pad(date.getUTCMonth()+1)}-${pad(date.getUTCDate())} ${pad(date.getUTCHours())}:${pad(date.getUTCMinutes())}:${pad(date.getUTCSeconds())}`;
                }
              } else if (inputType === 'date') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else {
                  const date = new Date(value + 'T00:00:00');
                  if (isNaN(date.getTime())) {
                    alert(`Invalid date value for field "${field}". Please enter a valid date.`);
                    throw new Error('Invalid date');
                  }
                  const pad = (n) => String(n).padStart(2,'0');
                  value = `${date.getUTCFullYear()}-${pad(date.getUTCMonth()+1)}-${pad(date.getUTCDate())}`;
                }
              } else if (inputType === 'time') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else {
                  value = value + ':00'; // Add seconds
                }
              }
            }

            data[field] = value;
          });
          
          statusEl.textContent = 'Saving...';
          const apiUrl = API_BASE + '/api/tables/' + encodeURIComponent(currentTable);
          console.log('Saving to:', apiUrl, { key, data });
          
          const res = await fetch(apiUrl, {
            method: 'PUT', 
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ key, data })
          });
          
          if(!res.ok){
            const errorText = await res.text();
            let errorData;
            try {
              errorData = JSON.parse(errorText);
            } catch {
              errorData = { error: `HTTP ${res.status}: ${errorText}` };
            }
            alert('Update failed: ' + (errorData.error || 'Unknown error') + (errorData.details ? '\nDetails: ' + errorData.details : ''));
            console.error('Save error:', res.status, errorData);
            statusEl.textContent = '';
            return;
          }
          
          const result = await res.json();
          if(result.updated){
            statusEl.textContent = 'Saved successfully!';
            // Refresh rows and close
            await loadRows(currentTable);
            setTimeout(() => { statusEl.textContent = ''; }, 2000);
            detailsModal.classList.remove('open');
            detailsModal.setAttribute('aria-hidden','true');
          } else {
            alert('Update did not affect any rows. The record may have been deleted.');
            statusEl.textContent = '';
          }
        } catch(err) {
          alert('Save error: ' + err.message);
          statusEl.textContent = '';
        }
      }

      detailsClose?.addEventListener('click', () => {
        detailsModal.classList.remove('open');
        detailsModal.setAttribute('aria-hidden','true');
        addMode = false;
        editMode = false;
        detailsModalTitle.textContent = 'Row Details';
        if(buttonsContainer){
          buttonsContainer.style.display = 'none';
        }
        if(statusButtonsSection){
          statusButtonsSection.style.display = 'none';
        }
        if(htxActionsSection){
          htxActionsSection.style.display = 'none';
        }
        if(pendingButtonsSection){
          pendingButtonsSection.style.display = 'none';
        }
      });
      detailsModal?.addEventListener('click', (e) => {
        if(e.target === detailsModal){
          detailsModal.classList.remove('open');
          detailsModal.setAttribute('aria-hidden','true');
          addMode = false;
          editMode = false;
          detailsModalTitle.textContent = 'Row Details';
          if(buttonsContainer){
            buttonsContainer.style.display = 'none';
          }
          if(statusButtonsSection){
            statusButtonsSection.style.display = 'none';
          }
          if(htxActionsSection){
            htxActionsSection.style.display = 'none';
          }
          if(pendingButtonsSection){
            pendingButtonsSection.style.display = 'none';
          }
        }
      });

      detailsEdit?.addEventListener('click', async () => {
        editMode = true;
        detailsEdit.style.display = 'none';
        detailsSave.style.display = '';
        detailsCancel.style.display = '';
        detailsDelete.style.display = '';
        await renderDetails(currentRow);
      });
      detailsCancel?.addEventListener('click', async () => {
        if(addMode) {
          addMode = false;
          detailsModal.classList.remove('open');
          detailsModal.setAttribute('aria-hidden','true');
          detailsModalTitle.textContent = 'Row Details';
        } else {
        editMode = false;
        detailsEdit.style.display = '';
        detailsSave.style.display = 'none';
        detailsCancel.style.display = 'none';
          detailsDelete.style.display = '';
          await renderDetails(currentRow);
        }
      });
      detailsSave?.addEventListener('click', () => { 
        if(addMode) {
          saveNewRow();
        } else {
          saveDetails();
        }
      });

      async function showAddForm(){
        if(!currentTable) {
          alert('Please select a table first');
          return;
        }
        try {
          await ensureMeta(currentTable);
          // Create an empty row object with all columns
          const emptyRow = {};
          const columns = currentMeta?.columns || [];
          
          // Initialize all columns with empty values
          // The backend will handle skipping auto-increment primary keys
          columns.forEach(col => {
            emptyRow[col] = null;
          });
          
          currentRow = emptyRow;
          addMode = true;
          editMode = true; // Show fields as editable
          detailsModalTitle.textContent = 'Add New Row';
          detailsEdit.style.display = 'none';
          detailsSave.style.display = '';
          detailsCancel.style.display = '';
          detailsDelete.style.display = 'none';
          if(buttonsContainer){
            buttonsContainer.style.display = 'none';
          }
          if(statusButtonsSection){
            statusButtonsSection.style.display = 'none';
          }
          if(htxActionsSection){
            htxActionsSection.style.display = 'none';
          }
          await renderDetails(emptyRow);
          detailsModal.classList.add('open');
          detailsModal.setAttribute('aria-hidden','false');
        } catch(err) {
          alert('Error loading table metadata: ' + err.message);
        }
      }

      async function saveNewRow(){
        if(!currentTable) return;
        try {
          await ensureMeta(currentTable);
          const inputs = detailsContent.querySelectorAll('input[data-field], select[data-field]');
          const data = {};
          const generatedColumnsSet = new Set((currentMeta?.generatedColumns)||[]);
          
          inputs.forEach(inp => {
            const field = inp.getAttribute('data-field');
            // Skip generated/virtual columns - they cannot be inserted
            if(generatedColumnsSet.has(field)){
              return;
            }
            const inputType = inp.type || (inp.tagName === 'SELECT' ? 'select' : 'text');
            let value = inp.value;

            // First, check column type and convert based on that (more reliable than input type)
            if (currentMeta?.columnTypes?.[field]) {
              const colType = parseColumnType(currentMeta.columnTypes[field]);
              if (colType.base === 'int') {
                if (value === '' || value === null || value === undefined) {
                  value = 0;
                } else {
                  const numVal = Number(value);
                  if (isNaN(numVal)) {
                    alert(`Invalid integer value for field "${field}". Please enter a valid number.`);
                    throw new Error('Invalid integer');
                  }
                  value = Math.floor(numVal);
                }
              } else if (colType.base === 'decimal') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else {
                  const numVal = Number(value);
                  if (isNaN(numVal)) {
                    alert(`Invalid decimal value for field "${field}". Please enter a valid number.`);
                    throw new Error('Invalid decimal');
                  }
                  value = numVal;
                }
              } else if (colType.base === 'datetime' || colType.base === 'timestamp') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else if (inputType === 'datetime-local') {
                  const date = new Date(value);
                  if (isNaN(date.getTime())) {
                    alert(`Invalid date/time value for field "${field}". Please enter a valid date and time.`);
                    throw new Error('Invalid datetime');
                  }
                  const pad = (n) => String(n).padStart(2,'0');
                  value = `${date.getUTCFullYear()}-${pad(date.getUTCMonth()+1)}-${pad(date.getUTCDate())} ${pad(date.getUTCHours())}:${pad(date.getUTCMinutes())}:${pad(date.getUTCSeconds())}`;
                }
              } else if (colType.base === 'date') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else if (inputType === 'date') {
                  const date = new Date(value + 'T00:00:00');
                  if (isNaN(date.getTime())) {
                    alert(`Invalid date value for field "${field}". Please enter a valid date.`);
                    throw new Error('Invalid date');
                  }
                  const pad = (n) => String(n).padStart(2,'0');
                  value = `${date.getUTCFullYear()}-${pad(date.getUTCMonth()+1)}-${pad(date.getUTCDate())}`;
                }
              } else if (colType.base === 'time') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else if (inputType === 'time') {
                  value = value + ':00';
                }
              }
            } else {
              // Fallback: convert based on input type if no column type info
              if (inputType === 'number') {
                if (value === '' || value === null || value === undefined) {
                  value = 0;
                } else {
                  const numVal = Number(value);
                  if (isNaN(numVal)) {
                    alert(`Invalid number value for field "${field}". Please enter a valid number.`);
                    throw new Error('Invalid number');
                  }
                  value = numVal;
                }
              } else if (inputType === 'datetime-local') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else {
                  const date = new Date(value);
                  if (isNaN(date.getTime())) {
                    alert(`Invalid date/time value for field "${field}". Please enter a valid date and time.`);
                    throw new Error('Invalid datetime');
                  }
                  const pad = (n) => String(n).padStart(2,'0');
                  value = `${date.getUTCFullYear()}-${pad(date.getUTCMonth()+1)}-${pad(date.getUTCDate())} ${pad(date.getUTCHours())}:${pad(date.getUTCMinutes())}:${pad(date.getUTCSeconds())}`;
                }
              } else if (inputType === 'date') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else {
                  const date = new Date(value + 'T00:00:00');
                  if (isNaN(date.getTime())) {
                    alert(`Invalid date value for field "${field}". Please enter a valid date.`);
                    throw new Error('Invalid date');
                  }
                  const pad = (n) => String(n).padStart(2,'0');
                  value = `${date.getUTCFullYear()}-${pad(date.getUTCMonth()+1)}-${pad(date.getUTCDate())}`;
                }
              } else if (inputType === 'time') {
                if (value === '' || value === null || value === undefined) {
                  value = null;
                } else {
                  value = value + ':00';
                }
              }
            }

            data[field] = value;
          });
          
          statusEl.textContent = 'Saving...';
          const apiUrl = API_BASE + '/api/tables/' + encodeURIComponent(currentTable);
          console.log('Saving new row to:', apiUrl, { data });
          
          const res = await fetch(apiUrl, {
            method: 'POST', 
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ data })
          });
          
          if(!res.ok){
            const errorText = await res.text();
            let errorData;
            try {
              errorData = JSON.parse(errorText);
            } catch {
              errorData = { error: `HTTP ${res.status}: ${errorText}` };
            }
            alert('Add failed: ' + (errorData.error || 'Unknown error') + (errorData.details ? '\nDetails: ' + errorData.details : ''));
            console.error('Save error:', res.status, errorData);
            statusEl.textContent = '';
            return;
          }
          
          const result = await res.json();
          if(result.inserted){
            statusEl.textContent = 'Added successfully!';
            // Refresh rows and close
            await loadRows(currentTable);
            setTimeout(() => { statusEl.textContent = ''; }, 2000);
            detailsModal.classList.remove('open');
            detailsModal.setAttribute('aria-hidden','true');
            addMode = false;
            editMode = false;
            detailsModalTitle.textContent = 'Row Details';
          } else {
            alert('Add did not succeed. Please check the data and try again.');
            statusEl.textContent = '';
          }
        } catch(err) {
          alert('Save error: ' + err.message);
          statusEl.textContent = '';
        }
      }

      addRowBtn?.addEventListener('click', () => {
        showAddForm();
      });

      importCsvBtn?.addEventListener('click', () => {
        csvFileInput?.click();
      });

      csvFileInput?.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        // Check if current table is allowed for CSV import
        const allowedTables = ['pendings', 'operasional services'];
        if (!currentTable || !allowedTables.some(t => normalize(t) === normalize(currentTable))) {
          alert('CSV import is only available for "pendings" and "operasional services" tables.');
          csvFileInput.value = '';
          return;
        }
        
        try {
          statusEl.textContent = 'Reading CSV file...';
          const text = await file.text();
          const rows = parseCSV(text);
          
          if (rows.length === 0) {
            alert('CSV file is empty or invalid.');
            statusEl.textContent = '';
            csvFileInput.value = '';
            return;
          }
          
          // Confirm import
          const confirmMsg = `Found ${rows.length} row(s) in CSV. Do you want to import them?`;
          if (!confirm(confirmMsg)) {
            csvFileInput.value = '';
            statusEl.textContent = '';
            return;
          }
          
          await importCSVData(rows);
          csvFileInput.value = '';
        } catch (err) {
          alert('Error reading CSV file: ' + err.message);
          statusEl.textContent = '';
          csvFileInput.value = '';
        }
      });

      function parseCSV(csvText) {
        const lines = csvText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        if (lines.length === 0) return [];
        
        // Parse header
        const headers = parseCSVLine(lines[0]);
        const rows = [];
        
        // Parse data rows
        for (let i = 1; i < lines.length; i++) {
          const values = parseCSVLine(lines[i]);
          if (values.length === 0) continue;
          
          const row = {};
          headers.forEach((header, index) => {
            const value = values[index] || '';
            // Remove quotes if present
            const cleanValue = value.replace(/^["']|["']$/g, '').trim();
            row[header.trim()] = cleanValue === '' ? null : cleanValue;
          });
          rows.push(row);
        }
        
        return rows;
      }

      function parseCSVLine(line) {
        const values = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          const nextChar = line[i + 1];
          
          if (char === '"') {
            if (inQuotes && nextChar === '"') {
              // Escaped quote
              current += '"';
              i++; // Skip next quote
            } else {
              // Toggle quote state
              inQuotes = !inQuotes;
            }
          } else if (char === ',' && !inQuotes) {
            // End of field
            values.push(current);
            current = '';
          } else {
            current += char;
          }
        }
        
        // Add last field
        values.push(current);
        return values;
      }

      async function importCSVData(rows) {
        if (!currentTable) return;
        
        try {
          await ensureMeta(currentTable);
          statusEl.textContent = `Importing ${rows.length} row(s)...`;
          
          const apiUrl = API_BASE + '/api/tables/' + encodeURIComponent(currentTable) + '/bulk-import';
          console.log('Importing CSV to:', apiUrl, { rowCount: rows.length });
          
          const res = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ rows })
          });
          
          if (!res.ok) {
            const errorText = await res.text();
            let errorData;
            try {
              errorData = JSON.parse(errorText);
            } catch {
              errorData = { error: `HTTP ${res.status}: ${errorText}` };
            }
            alert('Import failed: ' + (errorData.error || 'Unknown error') + (errorData.details ? '\nDetails: ' + errorData.details : ''));
            console.error('Import error:', res.status, errorData);
            statusEl.textContent = '';
            return;
          }
          
          const result = await res.json();
          const imported = result.inserted || 0;
          const failed = result.failed || 0;
          const errors = result.errors || [];
          
          if (imported > 0) {
            let message = `Successfully imported ${imported} row(s)`;
            if (failed > 0) {
              message += `, ${failed} failed`;
              if (errors.length > 0) {
                message += '\n\nErrors:\n' + errors.slice(0, 5).join('\n');
                if (errors.length > 5) {
                  message += `\n... and ${errors.length - 5} more errors`;
                }
              }
            }
            statusEl.textContent = `Successfully imported ${imported} row(s)${failed > 0 ? `, ${failed} failed` : ''}!`;
            if (failed > 0 && errors.length > 0) {
              console.error('Import errors:', errors);
              alert(message);
            }
            // Refresh rows
            await loadRows(currentTable);
            setTimeout(() => { statusEl.textContent = ''; }, 3000);
          } else {
            let errorMessage = `Import completed but no rows were inserted. ${failed > 0 ? `${failed} row(s) failed.` : ''}`;
            if (errors.length > 0) {
              errorMessage += '\n\nError details:\n' + errors.slice(0, 10).join('\n');
              if (errors.length > 10) {
                errorMessage += `\n... and ${errors.length - 10} more errors`;
              }
            }
            alert(errorMessage);
            console.error('Import errors:', errors);
            statusEl.textContent = '';
          }
        } catch (err) {
          alert('Import error: ' + err.message);
          statusEl.textContent = '';
        }
      }

      async function deleteRow(){
        if(!currentRow || !currentTable) return;
        
        // Confirm deletion
        if(!confirm('Are you sure you want to delete this row? This action cannot be undone.')){
          return;
        }
        
        try {
          await ensureMeta(currentTable);
          const pkCols = currentMeta.primaryKey || [];
          if(pkCols.length === 0){
            alert('Cannot delete: table has no primary key');
            return;
          }
          const key = {};
          for(const c of pkCols){ key[c] = currentRow[c]; }
          
          statusEl.textContent = 'Deleting...';
          const apiUrl = API_BASE + '/api/tables/' + encodeURIComponent(currentTable);
          console.log('Deleting from:', apiUrl, { key });
          
          const res = await fetch(apiUrl, {
            method: 'DELETE', 
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ key })
          });
          
          if(!res.ok){
            const errorText = await res.text();
            let errorData;
            try {
              errorData = JSON.parse(errorText);
            } catch {
              errorData = { error: `HTTP ${res.status}: ${errorText}` };
            }
            alert('Delete failed: ' + (errorData.error || 'Unknown error') + (errorData.details ? '\nDetails: ' + errorData.details : ''));
            console.error('Delete error:', res.status, errorData);
            statusEl.textContent = '';
            return;
          }
          
          const result = await res.json();
          if(result.deleted){
            statusEl.textContent = 'Deleted successfully!';
            // Refresh rows and close modal
            await loadRows(currentTable);
            setTimeout(() => { statusEl.textContent = ''; }, 2000);
            detailsModal.classList.remove('open');
            detailsModal.setAttribute('aria-hidden','true');
            addMode = false;
            editMode = false;
            detailsModalTitle.textContent = 'Row Details';
          } else {
            alert('Delete did not affect any rows. The record may have already been deleted.');
            statusEl.textContent = '';
          }
        } catch(err) {
          alert('Delete error: ' + err.message);
          statusEl.textContent = '';
        }
      }

      detailsDelete?.addEventListener('click', () => {
        deleteRow();
      });

      refreshBtn.onclick = () => loadTable(TARGET_TABLE, true, 'Order filters');

      function openStatusConfirm(statusValue){
        pendingStatusUpdate = statusValue;
        if(statusConfirmMessage){
          statusConfirmMessage.textContent = 'Do you want to update location ?';
        }
        if(statusConfirmModal){
          statusConfirmModal.classList.add('open');
          statusConfirmModal.setAttribute('aria-hidden','false');
        }
      }

      function closeStatusConfirm(){
        pendingStatusUpdate = null;
        if(statusConfirmModal){
          statusConfirmModal.classList.remove('open');
          statusConfirmModal.setAttribute('aria-hidden','true');
        }
      }

      function openSendToHtxConfirm(){
        if(statusConfirmMessage){
          statusConfirmMessage.textContent = 'Are you sure you want to send driver and vehicle details to Holiday Taxis?';
        }
        if(statusConfirmModal){
          statusConfirmModal.classList.add('open');
          statusConfirmModal.setAttribute('aria-hidden','false');
        }
        // Store a flag to indicate this is for Send to HTX
        pendingStatusUpdate = 'SEND_TO_HTX';
      }

      function openChangeCarConfirm(){
        if(statusConfirmMessage){
          statusConfirmMessage.textContent = 'Are you sure you want to de-allocate the vehicle and driver from this booking?';
        }
        if(statusConfirmModal){
          statusConfirmModal.classList.add('open');
          statusConfirmModal.setAttribute('aria-hidden','false');
        }
        // Store a flag to indicate this is for Change Car (de-allocation)
        pendingStatusUpdate = 'CHANGE_CAR';
      }

      function closeSendToHtxConfirm(){
        if(pendingStatusUpdate === 'SEND_TO_HTX'){
          pendingStatusUpdate = null;
        }
        if(statusConfirmModal){
          statusConfirmModal.classList.remove('open');
          statusConfirmModal.setAttribute('aria-hidden','true');
        }
      }

      function closeChangeCarConfirm(){
        if(pendingStatusUpdate === 'CHANGE_CAR'){
          pendingStatusUpdate = null;
        }
        if(statusConfirmModal){
          statusConfirmModal.classList.remove('open');
          statusConfirmModal.setAttribute('aria-hidden','true');
        }
      }

      function formatPhoneNumber(phone){
        if(!phone) return '';
        let formatted = String(phone).trim();
        // Remove any existing + sign and spaces
        formatted = formatted.replace(/^\+/, '').replace(/\s+/g, '');
        // Add + prefix if not empty
        if(formatted) {
          formatted = '+' + formatted;
        }
        return formatted;
      }

      async function sendToHtx(){
        if(!currentRow || !currentTable){
          closeSendToHtxConfirm();
          return;
        }

        try {
          // Find required fields using findColumnByName
          const bookingRefCol = findColumnByName(currentRow, 'Reference No.');
          const vehicleIdCol = findColumnByName(currentRow, 'car_id');
          const picNameCol = findColumnByName(currentRow, 'pic_name');
          const driverLicenseCol = findColumnByName(currentRow, 'driver_license');
          const picContactCol = findColumnByName(currentRow, 'pic_contact');
          const carBrandCol = findColumnByName(currentRow, 'car_brand');
          const colorVehicleCol = findColumnByName(currentRow, 'color_vehicle');
          const platMobilCol = findColumnByName(currentRow, 'plat_mobil');

          // Validate required fields
          if(!bookingRefCol){
            alert('Reference No. field not found in the row.');
            closeSendToHtxConfirm();
            return;
          }
          if(!vehicleIdCol){
            alert('car_id field not found in the row.');
            closeSendToHtxConfirm();
            return;
          }

          const bookingRef = currentRow[bookingRefCol];
          const vehicleIdentifier = currentRow[vehicleIdCol];

          if(!bookingRef || !vehicleIdentifier){
            alert('Reference No. and car_id are required to send to Holiday Taxis.');
            closeSendToHtxConfirm();
            return;
          }

          // Build request body
          const driver = {
            name: picNameCol ? (currentRow[picNameCol] || '') : '',
            licenseNumber: driverLicenseCol ? (currentRow[driverLicenseCol] || '') : '',
            phoneNumber: picContactCol ? formatPhoneNumber(currentRow[picContactCol]) : '',
            preferredContactMethod: 'WHATSAPP',
            contactMethods: ['VOICE', 'SMS', 'WHATSAPP']
          };

          const vehicle = {
            brand: carBrandCol ? (currentRow[carBrandCol] || '') : '',
            color: colorVehicleCol ? (currentRow[colorVehicleCol] || '') : '',
            registration: platMobilCol ? (currentRow[platMobilCol] || '') : ''
          };

          // Show loading state
          statusEl.textContent = 'Sending to Holiday Taxis...';

          // Call backend endpoint
          const res = await fetch(
            API_BASE + '/api/holiday-taxis/bookings/' + encodeURIComponent(bookingRef) + '/vehicles/' + encodeURIComponent(vehicleIdentifier),
            {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ driver, vehicle })
            }
          );

          const responseText = await res.text();
          let responseData;
          try {
            responseData = responseText ? JSON.parse(responseText) : {};
          } catch {
            responseData = { error: responseText || 'Unknown error' };
          }

          if(!res.ok){
            const errorMsg = responseData.error || responseData.details || `HTTP ${res.status}`;
            alert('Failed to send to Holiday Taxis: ' + errorMsg);
            statusEl.textContent = '';
            closeSendToHtxConfirm();
            return;
          }

          // Success
          statusEl.textContent = 'Successfully sent to Holiday Taxis!';
          setTimeout(() => {
            if(statusEl.textContent === 'Successfully sent to Holiday Taxis!'){
              statusEl.textContent = '';
            }
          }, 2000);
          showToast('Driver and vehicle details sent to Holiday Taxis');
          closeSendToHtxConfirm();

        } catch(err) {
          alert('Error sending to Holiday Taxis: ' + err.message);
          statusEl.textContent = '';
          closeSendToHtxConfirm();
        }
      }

      async function changeCar(){
        if(!currentRow || !currentTable){
          closeChangeCarConfirm();
          return;
        }

        try {
          // Find required fields using findColumnByName
          const bookingRefCol = findColumnByName(currentRow, 'Reference No.');
          const vehicleIdCol = findColumnByName(currentRow, 'car_id');

          // Validate required fields
          if(!bookingRefCol){
            alert('Reference No. field not found in the row.');
            closeChangeCarConfirm();
            return;
          }
          if(!vehicleIdCol){
            alert('car_id field not found in the row.');
            closeChangeCarConfirm();
            return;
          }

          const bookingRef = currentRow[bookingRefCol];
          const vehicleIdentifier = currentRow[vehicleIdCol];

          if(!bookingRef || !vehicleIdentifier){
            alert('Reference No. and car_id are required to de-allocate from Holiday Taxis.');
            closeChangeCarConfirm();
            return;
          }

          // Show loading state
          statusEl.textContent = 'De-allocating vehicle and driver...';

          // Call backend endpoint
          const res = await fetch(
            API_BASE + '/api/holiday-taxis/bookings/' + encodeURIComponent(bookingRef) + '/vehicles/' + encodeURIComponent(vehicleIdentifier),
            {
              method: 'DELETE',
              headers: { 'Content-Type': 'application/json' }
            }
          );

          const responseText = await res.text();
          let responseData;
          try {
            responseData = responseText ? JSON.parse(responseText) : {};
          } catch {
            responseData = { error: responseText || 'Unknown error' };
          }

          if(!res.ok){
            const errorMsg = responseData.error || responseData.details || `HTTP ${res.status}`;
            alert('Failed to de-allocate from Holiday Taxis: ' + errorMsg);
            statusEl.textContent = '';
            closeChangeCarConfirm();
            return;
          }

          // Success
          statusEl.textContent = 'Successfully de-allocated vehicle and driver!';
          setTimeout(() => {
            if(statusEl.textContent === 'Successfully de-allocated vehicle and driver!'){
              statusEl.textContent = '';
            }
          }, 2000);
          showToast('Vehicle and driver de-allocated from Holiday Taxis');
          closeChangeCarConfirm();

        } catch(err) {
          alert('Error de-allocating from Holiday Taxis: ' + err.message);
          statusEl.textContent = '';
          closeChangeCarConfirm();
        }
      }

      function showToast(message){
        if(!toastEl) return;
        toastEl.textContent = message;
        toastEl.classList.add('show');
        setTimeout(() => {
          toastEl.classList.remove('show');
        }, 2500);
      }

      function formatLatlong(coords){
        if(!coords) return null;
        const lat = Number(coords.latitude);
        const lon = Number(coords.longitude);
        if(!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
        return `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
      }

      function parseLatlong(latlongStr){
        if(!latlongStr) return null;
        const str = String(latlongStr).trim();
        const parts = str.split(',').map(s => s.trim());
        if(parts.length !== 2) return null;
        const lat = Number(parts[0]);
        const lng = Number(parts[1]);
        if(!Number.isFinite(lat) || !Number.isFinite(lng)) return null;
        return { lat, lng };
      }

      function formatTimestampUTC(){
        const now = new Date();
        const year = now.getUTCFullYear();
        const month = String(now.getUTCMonth() + 1).padStart(2, '0');
        const day = String(now.getUTCDate()).padStart(2, '0');
        const hours = String(now.getUTCHours()).padStart(2, '0');
        const minutes = String(now.getUTCMinutes()).padStart(2, '0');
        const seconds = String(now.getUTCSeconds()).padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}+00:00`;
      }

      let locationUpdateInterval = null;
      let currentTrackingRow = null;
      let currentTrackingStatus = null;

      function stopLocationTracking(){
        if(locationUpdateInterval){
          clearInterval(locationUpdateInterval);
          locationUpdateInterval = null;
        }
        currentTrackingRow = null;
        currentTrackingStatus = null;
      }

      async function sendLocationToHtx(row, status = null){
        if(!row) return false;
        
        try {
          const bookingRefCol = findColumnByName(row, 'Reference No.');
          const vehicleIdCol = findColumnByName(row, 'car_id');
          const latlongCol = findColumnByName(row, 'Latlong');
          const pickupStatusCol = findColumnByName(row, 'Pickup Status');

          if(!bookingRefCol || !vehicleIdCol){
            console.warn('Missing bookingRef or vehicleId for location update');
            return false;
          }

          const bookingRef = row[bookingRefCol];
          const vehicleIdentifier = row[vehicleIdCol];
          
          if(!bookingRef || !vehicleIdentifier){
            console.warn('Empty bookingRef or vehicleIdentifier for location update');
            return false;
          }

          // Get location from Latlong field
          let location = null;
          if(latlongCol && row[latlongCol]){
            location = parseLatlong(row[latlongCol]);
          }

          // If no location in database, try to get current GPS location
          if(!location){
            const { coords } = await requestCurrentPosition();
            if(coords){
              location = { lat: coords.latitude, lng: coords.longitude };
            } else {
              console.warn('No location available for update');
              return false;
            }
          }

          // Get status from Pickup Status field if not provided
          let statusValue = status;
          if(!statusValue && pickupStatusCol){
            statusValue = row[pickupStatusCol];
          }

          const timestamp = formatTimestampUTC();
          const requestBody = {
            timestamp,
            location: {
              lat: location.lat,
              lng: location.lng
            }
          };
          if(statusValue){
            requestBody.status = statusValue;
          }

          const res = await fetch(
            API_BASE + '/api/holiday-taxis/bookings/' + encodeURIComponent(bookingRef) + '/vehicles/' + encodeURIComponent(vehicleIdentifier) + '/location',
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(requestBody)
            }
          );

          if(!res.ok){
            const responseText = await res.text();
            let responseData;
            try {
              responseData = responseText ? JSON.parse(responseText) : {};
            } catch {
              responseData = { error: responseText || 'Unknown error' };
            }
            console.error('Failed to send location to Holiday Taxis:', responseData.error || responseData.details || `HTTP ${res.status}`);
            return false;
          }

          return true;
        } catch(err) {
          console.error('Error sending location to Holiday Taxis:', err);
          return false;
        }
      }

      async function sendLocationToHtxPeriodic(row){
        // For periodic updates, don't include status in the body (only timestamp and location)
        // This function: 1. Gets latest GPS from browser, 2. Updates database, 3. Sends to Holiday Taxis
        if(!row || !currentTable) return false;
        
        try {
          const bookingRefCol = findColumnByName(row, 'Reference No.');
          const vehicleIdCol = findColumnByName(row, 'car_id');
          const latlongCol = findColumnByName(row, 'Latlong');

          if(!bookingRefCol || !vehicleIdCol){
            return false;
          }

          const bookingRef = row[bookingRefCol];
          const vehicleIdentifier = row[vehicleIdCol];
          
          if(!bookingRef || !vehicleIdentifier){
            return false;
          }

          // Step 1: Get latest GPS location from browser
          const { coords, error } = await requestCurrentPosition();
          if(!coords || error){
            console.warn('Failed to get GPS location for periodic update:', error);
            return false;
          }

          const location = { lat: coords.latitude, lng: coords.longitude };
          const latlongValue = formatLatlong(coords); // Format as "lat, lng"

          // Step 2: Update "Latlong" field in database
          if(latlongCol){
            try {
              await ensureMeta(currentTable);
              const pkCols = currentMeta?.primaryKey || [];
              if(pkCols.length > 0){
                const key = {};
                pkCols.forEach(col => { key[col] = row[col]; });
                const payloadData = { [latlongCol]: latlongValue };
                const payload = { key, data: payloadData };

                const updateRes = await fetch(API_BASE + '/api/tables/' + encodeURIComponent(currentTable), {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(payload)
                });

                if(updateRes.ok){
                  const updateResult = await updateRes.json();
                  if(updateResult.updated){
                    // Update the row object with new latlong value
                    row[latlongCol] = latlongValue;
                    // Also update in originalRows if it exists
                    if(Array.isArray(originalRows)){
                      const matchIndex = originalRows.findIndex(r => pkCols.every(col => r[col] === row[col]));
                      if(matchIndex !== -1){
                        originalRows[matchIndex][latlongCol] = latlongValue;
                      }
                    }
                    console.log('Updated Latlong field in database:', latlongValue);
                  }
                } else {
                  console.warn('Failed to update Latlong field in database');
                }
              }
            } catch(updateErr) {
              console.error('Error updating Latlong field:', updateErr);
              // Continue to send to Holiday Taxis even if DB update fails
            }
          }

          // Step 3: Send latest location to Holiday Taxis
          const timestamp = formatTimestampUTC();
          const requestBody = {
            timestamp,
            location: {
              lat: location.lat,
              lng: location.lng
            }
          };

          const res = await fetch(
            API_BASE + '/api/holiday-taxis/bookings/' + encodeURIComponent(bookingRef) + '/vehicles/' + encodeURIComponent(vehicleIdentifier) + '/location',
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(requestBody)
            }
          );

          if(!res.ok){
            const responseText = await res.text();
            console.error('Failed to send periodic location to Holiday Taxis:', responseText);
            return false;
          }

          console.log('Sent periodic location to Holiday Taxis:', location);
          return true;
        } catch(err) {
          console.error('Error in periodic location update:', err);
          return false;
        }
      }

      function startLocationTracking(row, status){
        // Stop any existing tracking
        stopLocationTracking();

        if(!row || !status) return;

        // Determine interval based on status
        let intervalMs = null;
        if(status === 'BEFORE_PICKUP'){
          intervalMs = 3 * 60 * 1000; // 3 minutes (180 seconds)
        } else if(status === 'AFTER_PICKUP'){
          intervalMs = 5 * 60 * 1000; // 5 minutes (300 seconds)
        } else {
          // WAITING_FOR_CUSTOMER or COMPLETED - don't track
          return;
        }

        currentTrackingRow = row;
        currentTrackingStatus = status;

        // Send initial location with status (when button is clicked)
        sendLocationToHtx(row, status);

        // Set up periodic updates (without status in body)
        locationUpdateInterval = setInterval(async () => {
          if(currentTrackingRow && currentTrackingStatus){
            await sendLocationToHtxPeriodic(currentTrackingRow);
          }
        }, intervalMs);

        console.log(`Started location tracking for status ${status} with interval ${intervalMs}ms`);
      }

      function requestCurrentPosition(){
        return new Promise((resolve) => {
          if(!('geolocation' in navigator)){
            resolve({ coords: null, error: 'Geolocation not supported' });
            return;
          }
          navigator.geolocation.getCurrentPosition(
            (position) => resolve({ coords: position.coords, error: null }),
            (error) => resolve({ coords: null, error }),
            { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
          );
        });
      }

      async function applyStatusUpdate(statusValue, latlongValue){
        if(!statusValue || !currentRow || !currentTable){
          closeStatusConfirm();
          return;
        }
        try{
          await ensureMeta(currentTable);
          const pickupCol = findColumnByName(currentRow, 'Pickup Status');
          const latlongCol = findColumnByName(currentRow, 'Latlong');
          if(!pickupCol){
            alert('Pickup Status column not found.');
            closeStatusConfirm();
            return;
          }
          const pkCols = currentMeta?.primaryKey || [];
          if(pkCols.length === 0){
            alert('Cannot update: table has no primary key.');
            closeStatusConfirm();
            return;
          }
          const key = {};
          pkCols.forEach(col => { key[col] = currentRow[col]; });
          const payloadData = { [pickupCol]: statusValue };
          if(latlongCol && latlongValue){
            payloadData[latlongCol] = latlongValue;
          }
          const payload = { key, data: payloadData };
          statusEl.textContent = 'Saving...';
          const res = await fetch(API_BASE + '/api/tables/' + encodeURIComponent(currentTable), {
            method:'PUT',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify(payload)
          });
          if(!res.ok){
            const errorText = await res.text();
            let errorMessage = 'Update failed';
            try{
              const parsed = JSON.parse(errorText);
              errorMessage = parsed.error || errorMessage;
            }catch{
              if(errorText) errorMessage = errorText;
            }
            alert(errorMessage);
            statusEl.textContent = '';
            closeStatusConfirm();
            return;
          }
          const result = await res.json();
          if(result.updated){
            currentRow[pickupCol] = statusValue;
            if(latlongCol && latlongValue){
              currentRow[latlongCol] = latlongValue;
            }
            await renderDetails(currentRow);
            if(Array.isArray(originalRows)){
              const matchIndex = originalRows.findIndex(row => pkCols.every(col => row[col] === currentRow[col]));
              if(matchIndex !== -1){
                originalRows[matchIndex][pickupCol] = statusValue;
                if(latlongCol && latlongValue){
                  originalRows[matchIndex][latlongCol] = latlongValue;
                }
              }
            }
            applyFilters();
            
            // Send location to Holiday Taxis when status changes
            const bookingRefCol = findColumnByName(currentRow, 'Reference No.');
            const vehicleIdCol = findColumnByName(currentRow, 'car_id');
            if(bookingRefCol && vehicleIdCol && currentRow[bookingRefCol] && currentRow[vehicleIdCol]){
              // Send location update with status
              sendLocationToHtx(currentRow, statusValue).catch(err => {
                console.error('Failed to send location to Holiday Taxis:', err);
              });
            }

            // Manage automatic location tracking based on status
            if(statusValue === 'BEFORE_PICKUP'){
              startLocationTracking(currentRow, 'BEFORE_PICKUP');
            } else if(statusValue === 'WAITING_FOR_CUSTOMER'){
              stopLocationTracking();
            } else if(statusValue === 'AFTER_PICKUP'){
              startLocationTracking(currentRow, 'AFTER_PICKUP');
            } else if(statusValue === 'COMPLETED'){
              stopLocationTracking();
            }

            statusEl.textContent = latlongCol && latlongValue ? 'Pickup status & location updated!' : 'Pickup status updated!';
            setTimeout(() => {
              if(statusEl.textContent === 'Pickup status updated!' || statusEl.textContent === 'Pickup status & location updated!'){
                statusEl.textContent = '';
              }
            }, 2000);
          showToast(latlongCol && latlongValue ? 'Pickup status & location updated' : 'Pickup status updated');
          } else {
            alert('Update did not affect any rows.');
            statusEl.textContent = '';
          }
        }catch(err){
          alert('Save error: ' + err.message);
          statusEl.textContent = '';
        }finally{
          closeStatusConfirm();
        }
      }

      async function loadTable(tableName, showFilters = false, filterTitle = 'Order filters'){
        currentTable = tableName;
        try { await ensureMeta(tableName); } catch(e) { /* non-fatal */ }
        await loadRows(tableName);
        // Show or hide filters based on the table
        if(showFilters){
          if(filtersTitle) filtersTitle.textContent = filterTitle;
          filtersCard.style.display = 'block';
          
          const isOperasionalServices = normalize(tableName) === normalize(TARGET_TABLE);
          const isServicesTable = normalize(tableName) === 'services';
          const isPendingsTable = normalize(tableName) === 'pendings';
          
          if(checkboxFiltersContainer){
            // Show checkbox container for tables that need filters
            checkboxFiltersContainer.style.display = (isOperasionalServices || isServicesTable || isPendingsTable) ? 'flex' : 'none';
            
            // Show/hide specific checkboxes based on table
            const checkbox48HoursLabel = document.getElementById('checkbox-48-hours-label');
            const checkbox7DaysLabel = document.getElementById('checkbox-7-days-label');
            const checkboxPconLabel = document.getElementById('checkbox-pcon-label');
            const checkboxPammLabel = document.getElementById('checkbox-pamm-label');
            const checkboxPcanLabel = document.getElementById('checkbox-pcan-label');
            
            if(checkbox48HoursLabel) checkbox48HoursLabel.style.display = (isOperasionalServices || isServicesTable) ? 'flex' : 'none';
            if(checkbox7DaysLabel) checkbox7DaysLabel.style.display = (isOperasionalServices || isServicesTable) ? 'flex' : 'none';
            if(checkboxPconLabel) checkboxPconLabel.style.display = isPendingsTable ? 'flex' : 'none';
            if(checkboxPammLabel) checkboxPammLabel.style.display = isPendingsTable ? 'flex' : 'none';
            if(checkboxPcanLabel) checkboxPcanLabel.style.display = isPendingsTable ? 'flex' : 'none';
          }
        } else {
          filtersCard.style.display = 'none';
        }
      }

      function renderDatabaseConfig(){
        const keys = Object.keys(dbConfig);
        const html = keys.map(k => {
          const v = dbConfig[k];
          if(dbEditMode){
            const inputType = k === 'DB_PASSWORD' ? 'password' : 'text';
            return `<div class="kv"><div class="muted">${escapeHtml(k)}</div><div><input data-field="${escapeHtml(k)}" value="${escapeHtml(v)}" type="${inputType}" style="width:100%" /></div></div>`;
          } else {
            const display = k === 'DB_PASSWORD' ? 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢' : String(v);
            return `<div class="kv"><div class="muted">${escapeHtml(k)}</div><div>${escapeHtml(display)}</div></div>`;
          }
        }).join('');
        databaseContent.innerHTML = html || '<div class="muted">No config</div>';
      }

      function showDatabaseConfig(){
        // Close drawer if open
        appDrawer?.classList.remove('open');
        appDrawer?.setAttribute('aria-hidden','true');
        
        dbEditMode = false;
        dbEdit.style.display = '';
        dbSave.style.display = 'none';
        dbCancel.style.display = 'none';
        renderDatabaseConfig();
        databaseModal.classList.add('open');
        databaseModal.setAttribute('aria-hidden','false');
      }

      dbClose?.addEventListener('click', () => {
        databaseModal.classList.remove('open');
        databaseModal.setAttribute('aria-hidden','true');
      });
      databaseModal?.addEventListener('click', (e) => {
        if(e.target === databaseModal){
          databaseModal.classList.remove('open');
          databaseModal.setAttribute('aria-hidden','true');
        }
      });
      dbEdit?.addEventListener('click', () => {
        dbEditMode = true;
        dbEdit.style.display = 'none';
        dbSave.style.display = '';
        dbCancel.style.display = '';
        renderDatabaseConfig();
      });
      dbCancel?.addEventListener('click', () => {
        dbEditMode = false;
        dbEdit.style.display = '';
        dbSave.style.display = 'none';
        dbCancel.style.display = 'none';
        renderDatabaseConfig();
      });
      dbSave?.addEventListener('click', () => {
        const inputs = databaseContent.querySelectorAll('input[data-field]');
        inputs.forEach(inp => { const field = inp.getAttribute('data-field'); dbConfig[field] = inp.value; });
        alert('Database configuration saved locally. Note: This does not update the server config.');
        dbEditMode = false;
        dbEdit.style.display = '';
        dbSave.style.display = 'none';
        dbCancel.style.display = 'none';
        renderDatabaseConfig();
      });

      document.getElementById('btn-database')?.addEventListener('click', showDatabaseConfig);

      function renderApiConfig(){
        if(!apiContent) return;
        const rows = [
          { key: 'endpoint', label: 'Endpoint URL', type: 'text' },
          { key: 'apiKey', label: 'API Key', type: 'password' },
          { key: 'apiVersion', label: 'API Version', type: 'text' }
        ];
        const html = rows.map(row => {
          const value = holidayApiConfig[row.key] ?? '';
          if(apiEditMode){
            return `<div class="kv"><div class="muted">${escapeHtml(row.label)}</div><div><input data-field="${escapeHtml(row.key)}" value="${escapeHtml(value)}" type="${row.type}" style="width:100%" /></div></div>`;
          }
          const display = row.key === 'apiKey' && value ? 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢' : String(value || '');
          return `<div class="kv"><div class="muted">${escapeHtml(row.label)}</div><div>${escapeHtml(display)}</div></div>`;
        }).join('');
        apiContent.innerHTML = html || '<div class="muted">No config</div>';
      }

      async function loadHolidayApiConfig(){
        try {
          const res = await fetch(API_BASE + '/api/holiday-taxis/config');
          if(res.ok){
            const data = await res.json();
            holidayApiConfig = { ...holidayApiConfig, ...data };
          }
        } catch (err) {
          console.error('Failed to load Holiday Taxis config', err);
        }
      }

      async function showApiConfig(){
        // Close drawer if open
        appDrawer?.classList.remove('open');
        appDrawer?.setAttribute('aria-hidden','true');
        apiEditMode = false;
        apiEdit.style.display = '';
        apiSave.style.display = 'none';
        apiCancel.style.display = 'none';
        await loadHolidayApiConfig();
        renderApiConfig();
        apiModal.classList.add('open');
        apiModal.setAttribute('aria-hidden','false');
      }

      apiClose?.addEventListener('click', () => {
        apiModal.classList.remove('open');
        apiModal.setAttribute('aria-hidden','true');
      });

      apiModal?.addEventListener('click', (e) => {
        if(e.target === apiModal){
          apiModal.classList.remove('open');
          apiModal.setAttribute('aria-hidden','true');
        }
      });

      apiEdit?.addEventListener('click', () => {
        apiEditMode = true;
        apiEdit.style.display = 'none';
        apiSave.style.display = '';
        apiCancel.style.display = '';
        renderApiConfig();
      });

      apiCancel?.addEventListener('click', () => {
        apiEditMode = false;
        apiEdit.style.display = '';
        apiSave.style.display = 'none';
        apiCancel.style.display = 'none';
        renderApiConfig();
      });

      apiSave?.addEventListener('click', async () => {
        if(!apiContent) return;
        const inputs = apiContent.querySelectorAll('input[data-field]');
        const updated = { ...holidayApiConfig };
        inputs.forEach(inp => {
          const field = inp.getAttribute('data-field');
          updated[field] = inp.value.trim();
        });
        try {
          const res = await fetch(API_BASE + '/api/holiday-taxis/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updated)
          });
          if(!res.ok){
            const errorText = await res.text();
            let errorData;
            try {
              errorData = JSON.parse(errorText);
            } catch {
              errorData = { error: `HTTP ${res.status}: ${errorText}` };
            }
            alert('Failed to save API config: ' + (errorData.error || 'Unknown error'));
            return;
          }
          const data = await res.json();
          holidayApiConfig = { ...holidayApiConfig, ...(data.config || updated) };
          apiEditMode = false;
          apiEdit.style.display = '';
          apiSave.style.display = 'none';
          apiCancel.style.display = 'none';
          renderApiConfig();
          showToast('API configuration saved');
        } catch(err) {
          alert('Save error: ' + err.message);
        }
      });

      document.getElementById('btn-api-connection')?.addEventListener('click', () => {
        showApiConfig();
      });

      document.getElementById('btn-logout')?.addEventListener('click', () => {
        appDrawer?.classList.remove('open');
        appDrawer?.setAttribute('aria-hidden','true');
        if(confirm('Are you sure you want to logout?')){
          logoutUser();
        }
      });

      if('serviceWorker' in navigator){
        navigator.serviceWorker.register('/sw.js').catch(()=>{});
      }

      const statusButtons = statusButtonsSection?.querySelectorAll('[data-status-value]');
      statusButtons?.forEach(button => {
        button.addEventListener('click', (event) => {
          event.preventDefault();
          if(!currentRow){
            alert('Please select a row before updating status.');
            return;
          }
          const statusValue = button.getAttribute('data-status-value');
          if(statusValue){
            openStatusConfirm(statusValue);
          }
        });
      });

      const pendingButtons = pendingButtonsSection?.querySelectorAll('[data-pending-action]');
      pendingButtons?.forEach(button => {
        button.addEventListener('click', (event) => {
          event.preventDefault();
          if(!currentRow){
            alert('Please select a row before performing action.');
            return;
          }
          const action = button.getAttribute('data-pending-action');
          if(action){
            openPendingConfirm(action);
          }
        });
      });

      document.getElementById('btn-send-to-htx')?.addEventListener('click', (event) => {
        event.preventDefault();
        if(!currentRow){
          alert('Please select a row before sending to HTX.');
          return;
        }
        openSendToHtxConfirm();
      });

      document.getElementById('btn-change-car')?.addEventListener('click', (event) => {
        event.preventDefault();
        if(!currentRow){
          alert('Please select a row before changing car.');
          return;
        }
        openChangeCarConfirm();
      });

      function openPendingConfirm(action){
        pendingActionRequest = action;
        if(pendingConfirmMessage){
          pendingConfirmMessage.textContent = `Are you sure you want to apply "${action}" to this booking?`;
        }
        if(pendingConfirmModal){
          pendingConfirmModal.classList.add('open');
          pendingConfirmModal.setAttribute('aria-hidden','false');
        }
      }

      function closePendingConfirm(){
        pendingActionRequest = null;
        if(pendingConfirmModal){
          pendingConfirmModal.classList.remove('open');
          pendingConfirmModal.setAttribute('aria-hidden','true');
        }
      }

      pendingConfirmYes?.addEventListener('click', () => {
        if(pendingActionRequest){
          handlePendingAction(pendingActionRequest);
        }
        closePendingConfirm();
      });

      pendingConfirmNo?.addEventListener('click', () => {
        closePendingConfirm();
      });

      pendingConfirmClose?.addEventListener('click', () => {
        closePendingConfirm();
      });

      pendingConfirmModal?.addEventListener('click', (e) => {
        if(e.target === pendingConfirmModal){
          closePendingConfirm();
        }
      });

      async function handlePendingAction(action){
        if(!currentRow || !currentTable) return;
        
        // Confirm action
        const actionNames = {
          'ACON': 'ACON',
          'AAMM': 'AAMM',
          'ACAN': 'ACAN',
          'ACTION4': 'Action 4'
        };
        const actionName = actionNames[action] || action;
        
        try {
          await ensureMeta(currentTable);
          const pkCols = currentMeta.primaryKey || [];
          if(pkCols.length === 0){
            alert('Cannot update: table has no primary key');
            return;
          }
          
          // Determine which column to update
          let statusCol = null;
          const isPendingsTable = normalize(currentTable) === 'pendings';
          if(isPendingsTable){
            statusCol = findColumnByName(currentRow, 'StatusCode');
          }
          if(!statusCol){
            statusCol = findColumnByName(currentRow, 'Status') || findColumnByName(currentRow, 'Action Status') || findColumnByName(currentRow, 'Pending Status');
          }
          
          const key = {};
          for(const c of pkCols){ key[c] = currentRow[c]; }
          
          const data = {};
          if(statusCol){
            data[statusCol] = action;
          } else {
            // If no status column found, show warning
            alert('Status column not found. Please check your table structure.');
            return;
          }
          
          statusEl.textContent = `Updating ${actionName}...`;
          const apiUrl = API_BASE + '/api/tables/' + encodeURIComponent(currentTable);
          console.log('Updating pending action:', apiUrl, { key, data });
          
          const res = await fetch(apiUrl, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ key, data })
          });
          
          if(!res.ok){
            const errorText = await res.text();
            let errorData;
            try {
              errorData = JSON.parse(errorText);
            } catch {
              errorData = { error: `HTTP ${res.status}: ${errorText}` };
            }
            alert('Update failed: ' + (errorData.error || 'Unknown error') + (errorData.details ? '\nDetails: ' + errorData.details : ''));
            console.error('Update error:', res.status, errorData);
            statusEl.textContent = '';
            return;
          }
          
          const result = await res.json();
          if(result.updated){
            statusEl.textContent = `${actionName} action completed successfully!`;
            // Update local row data so the modal reflects the new value immediately
            if(statusCol){
              currentRow[statusCol] = action;
              await renderDetails(currentRow);
            }
            if(isPendingsTable && action !== 'ACTION4'){
              await syncHolidayStatus(action);
            }
            // Refresh rows and update current row
            await loadRows(currentTable);
            setTimeout(() => { statusEl.textContent = ''; }, 2000);
            showToast(`${actionName} updated successfully`);
          } else {
            alert('Update did not affect any rows. The record may have been deleted.');
            statusEl.textContent = '';
          }
        } catch(err) {
          alert('Action error: ' + err.message);
          statusEl.textContent = '';
        }
      }

      async function syncHolidayStatus(action){
        if(!currentRow) return;
        const bookingRefCol = findColumnByName(currentRow, 'SUPP_REF');
        if(!bookingRefCol){
          console.warn('SUPP_REF column not found, skipping Holiday Taxis sync');
          return;
        }
        const bookingRef = currentRow[bookingRefCol];
        if(!bookingRef){
          console.warn('SUPP_REF value missing, skipping Holiday Taxis sync');
          return;
        }
        try {
          const url = API_BASE + '/api/holiday-taxis/bookings/' + encodeURIComponent(bookingRef) + '/status';
          const res = await fetch(url, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ status: action })
          });
          if(!res.ok){
            const errorText = await res.text();
            let errorData;
            try {
              errorData = JSON.parse(errorText);
            } catch {
              errorData = { error: `HTTP ${res.status}: ${errorText}` };
            }
            alert('Holiday Taxis update failed: ' + (errorData.error || 'Unknown error') + (errorData.details ? '\nDetails: ' + errorData.details : ''));
            console.error('Holiday Taxis update error:', res.status, errorData);
            return;
          }
          await res.json().catch(() => ({}));
          showToast('Holiday Taxis updated');
        } catch(err) {
          alert('Holiday Taxis update error: ' + err.message);
        }
      }

      function setStatusConfirmDisabled(disabled){
        if(statusConfirmYes) statusConfirmYes.disabled = disabled;
        if(statusConfirmNo) statusConfirmNo.disabled = disabled;
        if(statusConfirmClose) statusConfirmClose.disabled = disabled;
      }

      statusConfirmYes?.addEventListener('click', async () => {
        if(pendingStatusUpdate === 'SEND_TO_HTX'){
          await sendToHtx();
          return;
        }
        if(pendingStatusUpdate === 'CHANGE_CAR'){
          await changeCar();
          return;
        }
        if(!pendingStatusUpdate){
          closeStatusConfirm();
          return;
        }
        setStatusConfirmDisabled(true);
        let latlongValue = null;
        try{
          const { coords, error } = await requestCurrentPosition();
          if(coords){
            latlongValue = formatLatlong(coords);
          } else if(error){
            console.warn('Geolocation error:', error);
            alert('Unable to get current location. Pickup status will be updated without location.');
          }
        }finally{
          setStatusConfirmDisabled(false);
        }
        applyStatusUpdate(pendingStatusUpdate, latlongValue);
      });
      statusConfirmNo?.addEventListener('click', () => {
        if(pendingStatusUpdate === 'SEND_TO_HTX'){
          closeSendToHtxConfirm();
        } else if(pendingStatusUpdate === 'CHANGE_CAR'){
          closeChangeCarConfirm();
        } else {
          closeStatusConfirm();
        }
      });
      statusConfirmClose?.addEventListener('click', () => {
        if(pendingStatusUpdate === 'SEND_TO_HTX'){
          closeSendToHtxConfirm();
        } else if(pendingStatusUpdate === 'CHANGE_CAR'){
          closeChangeCarConfirm();
        } else {
          closeStatusConfirm();
        }
      });
      statusConfirmModal?.addEventListener('click', (e) => {
        if(e.target === statusConfirmModal){
          if(pendingStatusUpdate === 'SEND_TO_HTX'){
            closeSendToHtxConfirm();
          } else if(pendingStatusUpdate === 'CHANGE_CAR'){
            closeChangeCarConfirm();
          } else {
            closeStatusConfirm();
          }
        }
      });
    </script>
  </body>
  </html>


